<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Chat App</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #0d6efd;
            --primary-color-dark: #0a58ca;
            --primary-color-text: #007bff;
            --reply-border-color: #0d6efd;
            --sent-message-bg: var(--primary-color);
            --sent-message-text: white;
        }

        html, body {
            height: 100%;
            overflow: hidden; /* Prevent body from scrolling */
        }

        body {
            font-family: 'Inter', sans-serif;
            background: radial-gradient(circle at top left, #e0eafc, #cfdef3);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 5px; /* Add some padding around the container */
        }
        .chat-container {
            max-width: 600px;
            width: 100%;
            height: 100%; /* Fill the padded body */
            max-height: 98vh; /* A bit of vertical margin */
            border: 1px solid #ddd;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            background-color: white;
            display: flex; /* Make it a flex container */
            flex-direction: column; /* Stack children vertically */
        }

        /* Make all screens behave as flex containers */
        #registration-screen, #contacts-screen, #status-screen, #chat-screen {
            display: flex; /* This will be set by JS, but we define the direction here */
            flex-direction: column;
            flex-grow: 1; /* Allow the screen to grow and fill the container */
            overflow: hidden; /* Prevent internal scrolling on the screen itself */
        }

        .chat-header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--primary-color-dark);
            flex-shrink: 0; /* Header should not shrink */
        }

        .chat-messages {
            /* height: 400px; /* REMOVED FIXED HEIGHT */
            flex-grow: 1; /* Allow message area to take all available space */
            overflow-y: auto;
            padding: 15px;
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Adjust contacts and status list containers for flex layout */
        #contacts-screen .p-3 {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #status-list {
            overflow-y: auto;
            flex-grow: 1;
        }

        #contacts-list {
           flex-grow: 1;
        }

        /* The input area at the bottom of the chat */
        #chat-screen .p-3.border-top {
            flex-shrink: 0; /* Input area should not shrink */
        }

        .message {
            margin-bottom: 5px;
            padding: 10px 15px;
            border-radius: 20px;
            max-width: 80%;
            word-wrap: break-word;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            transition: transform 0.2s ease-out;
            position: relative;
        }
        .message:hover {
            transform: translateY(-2px);
        }
        .sent {
            background-color: var(--sent-message-bg);
            color: var(--sent-message-text);
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }
        .received {
            background-color: #e9ecef;
            color: #333;
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }
        .status-info {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            text-align: right;
        }
        .contact-item {
            cursor: pointer;
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            transition: background-color: 0.3s ease, transform 0.2s ease-out;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .contact-item:hover {
            background-color: #f0f2f5;
            transform: translateX(5px);
        }
        .unread-dot {
            background-color: #dc3545;
            border-radius: 50%;
            width: 10px;
            height: 10px;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }
        .unread-count {
            background-color: #dc3545;
            color: white;
            border-radius: 50%;
            padding: 4px 8px;
            font-size: 11px;
            margin-left: 10px;
            min-width: 25px;
            text-align: center;
        }
        #notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
            width: 320px;
        }
        .notification-toast {
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            transition: all 0.4s ease-out;
            margin-bottom: 15px;
            border-radius: 10px;
            overflow: hidden;
            background-color: white;
            border: none;
        }
        .notification-toast .toast-header {
            background-color: var(--primary-color);
            color: white;
            border-bottom: 1px solid var(--primary-color-dark);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .notification-toast .toast-body {
            padding: 15px;
            color: #333;
        }
        .notification-toast .btn-close {
            color: white;
            filter: invert(1);
            opacity: 0.8;
        }
        .notification-toast .btn-close:hover {
            opacity: 1;
        }
        .typing-indicator {
            display: inline-block;
            padding: 5px 12px;
            background-color: #e9ecef;
            border-radius: 15px;
            font-size: 13px;
            color: #6c757d;
            margin-top: 5px;
        }
        .message-status {
            font-size: 11px;
            margin-left: 8px;
            opacity: 0.8;
        }
        .message-status.delivered {
            color: #ccc;
        }
        .message-status.read {
            color: #00e676;
        }
        .message-status.double-check {
            position: relative;
            top: -2px;
        }
        #game-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        #game-board {
            width: 350px;
            height: 500px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        #game-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        #game-players {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .player-info {
            text-align: center;
            padding: 5px;
            border-radius: 5px;
            width: 48%;
        }
        .player-info.you {
            background-color: #e3f2fd;
        }
        .player-info.opponent {
            background-color: #f3e5f5;
        }
        .player-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .player-score {
            font-size: 18px;
            color: var(--primary-color);
        }
        .player-battery {
            font-size: 12px;
            color: #666;
        }
        #game-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-gap: 5px;
            flex-grow: 1;
        }
        .game-cell {
            background-color: #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }
        .game-cell:hover {
            transform: scale(1.05);
        }
        .cell-popped {
            animation: pop 0.3s;
        }
        #game-timer {
            font-weight: bold;
            font-size: 18px;
            color: #dc3545;
            text-align: center;
            margin: 10px 0;
        }
        #game-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        .profile-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #fff;
            color: #0d6efd;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-right: 10px;
            flex-shrink: 0;
            background-image: linear-gradient(45deg, #0d6efd, #00aaff);
            color: white;
            border: 2px solid #ffffff;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            overflow: hidden;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        .profile-logo:hover {
            transform: scale(1.05) rotate(5deg);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }
        .contact-item .profile-logo {
            width: 35px;
            height: 35px;
            font-size: 1em;
        }
        .chat-header .profile-logo {
            width: 35px;
            height: 35px;
            font-size: 1em;
            margin-right: 10px;
            cursor: pointer;
        }
        .chat-header .d-flex {
            align-items: center;
        }
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1060; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.4); 
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 400px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            text-align: center;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: bold;
        }
        .modal-body {
            margin-bottom: 20px;
        }
        .modal-footer {
            display: flex;
            justify-content: space-around;
        }
        .close-modal-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-modal-btn:hover,
        .close-modal-btn:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .contact-item .text-muted.small {
            display: block; 
            margin-bottom: 5px; 
        }

        .contact-item strong {
            display: block; 
        }
        .context-menu {
            display: none;
            position: fixed; 
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001; 
            min-width: 120px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .context-menu.show {
            display: block;
            opacity: 1;
            transform: translateY(0); 
        }

        .context-menu button {
            background: none;
            border: none;
            padding: 10px 15px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-size: 0.95em;
            color: #333;
            transition: background-color 0.2s ease;
        }

        .context-menu button:hover {
            background-color: #f0f2f5;
        }

        .context-menu button:not(:last-child) {
            border-bottom: 1px solid #eee;
        }

        .edited-tag {
            font-size: 0.8em;
            color: #888;
            margin-left: 5px;
        }

        .deleted-message {
            font-style: italic;
            color: #888;
            background-color: #f0f0f0;
            padding: 10px 15px;
            border-radius: 20px;
            max-width: 80%;
            word-wrap: break-word;
            margin-bottom: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.03);
        }

        .reactions-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid rgba(0,0,0,0.05);
        }
        .reaction-bubble {
            display: inline-flex;
            align-items: center;
            background-color: rgba(0,0,0,0.05);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.85em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .reaction-bubble:hover {
            background-color: rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        .reaction-bubble.reacted-by-me {
            background-color: var(--primary-color);
            color: white;
            border: 1px solid var(--primary-color-dark);
        }
        .reaction-bubble span {
            margin-right: 3px;
        }
        .emoji-picker-modal .modal-content {
            max-width: 320px;
        }
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            padding: 10px;
        }
        .emoji-grid button {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }
        .emoji-grid button:hover {
            background-color: #eee;
        }

        .replied-message-preview {
            background-color: rgba(0,0,0,0.05);
            border-left: 4px solid var(--reply-border-color);
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 5px;
            font-size: 0.85em;
            color: #555;
        }
        .replied-message-preview strong {
            color: var(--primary-color);
        }
        .replied-message-preview .original-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            display: block;
        }
        .message.sent .replied-message-preview {
            background-color: rgba(255,255,255,0.2); 
            border-left-color: white;
            color: rgba(255,255,255,0.8);
        }
        .message.sent .replied-message-preview strong {
            color: white;
        }

        .reply-input-wrapper {
            background-color: #e9ecef;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            color: #333;
            border-left: 4px solid var(--reply-border-color);
        }
        .reply-input-wrapper .reply-content {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 10px;
        }
        .reply-input-wrapper .clear-reply-btn {
            background: none;
            border: none;
            font-size: 1.2em;
            color: #666;
            cursor: pointer;
            padding: 0 5px;
        }
        .reply-input-wrapper .clear-reply-btn:hover {
            color: #dc3545;
        }

        #new-message-indicator {
            border-radius: 10px;
            font-weight: 500;
            margin-bottom: 15px; 
            display: none; 
            background-color: #e0f7fa; 
            color: var(--primary-color-text); 
            border: 1px solid #b2ebf2; 
            padding: 8px 15px; 
            text-align: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); 
            transition: all 0.2s ease-in-out;
        }
        #new-message-indicator:hover {
            background-color: #b2ebf2;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .game-result-message, .system-message {
            background-color: #e3f2fd;
            color: #0d6efd;
            font-weight: 500;
            text-align: center;
            margin: 10px auto;
            max-width: 90%;
            border: 1px solid #bde0fe;
            border-radius: 10px;
        }

        .charging-alert {
            background-color: #fff3cd;
            color: #664d03;
            padding: 10px 15px;
            border: 1px solid #ffecb5;
            border-radius: 8px;
            margin: 0 0 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }
        .charging-alert .btn-close {
            padding: 0;
            width: 1em;
            height: 1em;
            font-size: 1em;
        }

        @keyframes pop {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); }
        }

        .connecting-message {
            text-align: center;
            color: var(--primary-color);
            font-weight: 500;
            margin-top: 15px;
        }
        #registration-screen {
            background: linear-gradient(135deg, #ffffff 0%, #f8faff 100%);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            border: 1px solid #e0e0e0;
        }
        #registration-screen .chat-header {
            border-radius: 15px 15px 0 0;
            background: linear-gradient(90deg, var(--primary-color), #00aaff);
            padding: 20px;
            font-size: 1.5em;
            text-align: center;
            justify-content: center;
            margin: -30px -30px 20px -30px; 
        }
        #registration-screen .chat-header h5 {
            margin: 0;
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        #registration-screen .form-label {
            font-weight: 500;
            color: #555;
            margin-bottom: 8px;
        }
        #registration-screen .form-control {
            border: 1px solid #ced4da;
            padding: 12px 18px;
            font-size: 1.05em;
            border-radius: 12px; 
            transition: all 0.3s ease;
        }
        #registration-screen .form-control:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25), 0 2px 8px rgba(0, 123, 255, 0.1); 
        }
        #registration-screen .btn-primary {
            background: linear-gradient(90deg, var(--primary-color-text), #00c6ff);
            border: none;
            padding: 12px 25px;
            font-size: 1.1em;
            font-weight: 600;
            border-radius: 12px; 
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.3); 
            transition: all 0.3s ease;
        }
        #registration-screen .btn-primary:hover {
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4); 
            transform: translateY(-3px); 
        }
        #registration-screen .text-danger {
            font-size: 0.9em;
            color: #dc3545;
            margin-top: 5px;
        }
        #registration-screen .connecting-message {
            color: var(--primary-color);
            font-size: 0.95em;
            margin-top: 15px;
            font-weight: 500;
        }
        
        #contacts-screen .chat-header .btn-secondary {
            background-color: #6c757d;
            border-color: #6c757d;
            color: white;
            border-radius: 8px;
            padding: 8px 15px;
            font-size: 0.9em;
            transition: background-color 0.2s, border-color 0.2s;
        }
        #contacts-screen .chat-header .btn-secondary:hover {
            background-color: #5a6268;
            border-color: #545b62;
        }

        #bio-modal .modal-content {
            text-align: left;
            padding: 25px;
        }
        #bio-modal .modal-header {
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        #bio-modal .modal-body {
            font-size: 1em;
            line-height: 1.5;
            color: #444;
            text-align: left;
            word-wrap: break-word; 
            white-space: pre-wrap; 
            max-height: 300px; 
            overflow-y: auto; 
        }
        #bio-modal .modal-body.no-bio {
            font-style: italic;
            color: #888;
        }
        #bio-modal .modal-footer {
            justify-content: flex-end;
            border-top: 1px solid #eee;
            padding-top: 15px;
            margin-top: 15px;
        }

        .theme-swatch {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }
        .theme-swatch:hover {
            transform: scale(1.1);
        }
        .theme-swatch.active {
            border-color: #333;
            box-shadow: 0 0 8px rgba(0,0,0,0.4);
        }
        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        .btn-primary:hover {
            background-color: var(--primary-color-dark);
            border-color: var(--primary-color-dark);
        }

        .favorite-star {
            font-size: 1.5em;
            color: #ffd700; 
            cursor: pointer;
            transition: transform 0.2s;
            margin-left: 15px;
        }
        .favorite-star:hover {
            transform: scale(1.2);
        }
        .contact-info-container {
            flex-grow: 1;
            display: flex;
            align-items: center;
        }
        .status-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .status-item:hover {
            background-color: #f8f9fa;
        }
        .status-item p {
            margin: 0;
            color: #555;
            font-style: italic;
        }
        .list-group-header {
            font-size: 0.9em;
            color: #6c757d;
        }
        #status-viewers-list {
            max-height: 200px;
            overflow-y: auto;
        }

        #doodle-modal .modal-content {
            max-width: 90vw;
            width: 90vw;
            height: 85vh;
            display: flex;
            flex-direction: column;
        }
        #doodle-modal .modal-body {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #doodle-canvas {
            border: 1px solid #ccc;
            border-radius: 8px;
            cursor: crosshair;
            touch-action: none;
            width: 100%;
            flex-grow: 1;
        }
        .doodle-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            gap: 10px;
        }
        .color-palette {
            display: flex;
            gap: 8px;
        }
        .color-swatch {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        .color-swatch.active {
            border-color: #333;
        }
        .brush-size-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .message-doodle {
            max-width: 100%;
            border-radius: 15px;
            border: 2px solid #eee;
            background-color: white;
            padding: 5px;
        }
        .chat-input-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .chat-input-buttons .btn {
            flex-grow: 1;
        }

        #live-doodle-modal .modal-content {
            max-width: 90vw; 
            width: 90vw;
            height: 90vh;
            display: flex;
            flex-direction: column;
        }
        #live-doodle-modal .modal-body {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        #live-doodle-canvas-container {
            flex-grow: 1;
            position: relative;
        }
        #live-doodle-canvas {
            border: 2px solid #333;
            border-radius: 8px;
            cursor: crosshair;
            touch-action: none;
            background-color: white;
            width: 100%;
            height: 100%;
        }
        .live-doodle-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 10px 0;
            gap: 15px;
        }
        /* Disappearing Messages Styles */
        .chat-header-btn {
            background: none;
            border: none;
            color: white;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .chat-header-btn:hover {
            opacity: 1;
        }
        #disappearing-status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
            background-color: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
        }
        #disappearing-messages-modal .modal-body {
            text-align: left;
        }
        #view-status-btn {
            position: relative;
        }
        #new-status-indicator-dot {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 10px;
            height: 10px;
            background-color: #dc3545;
            border-radius: 50%;
            border: 2px solid white;
            display: none; /* Hidden by default */
        }
        /* Voice Note Styles */
        #voice-record-btn {
            background: none;
            border: none;
            padding: 0 10px;
            cursor: pointer;
        }
        #voice-record-btn svg {
            width: 24px;
            height: 24px;
            fill: #6c757d;
            transition: fill 0.2s;
        }
        #voice-record-btn:hover svg {
            fill: var(--primary-color);
        }
        #voice-record-btn.recording svg {
            fill: #dc3545;
        }
        #voice-recording-ui {
            display: none;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        #recording-timer {
            color: #dc3545;
            font-weight: bold;
        }
        #stop-recording-btn {
            background-color: #dc3545;
            color: white;
        }
        .message-audio {
            width: 250px;
        }
        /* Voice Call Styles */
        #call-modal .modal-content {
            text-align: center;
        }
        #call-modal .profile-logo {
            width: 80px;
            height: 80px;
            font-size: 2.5em;
            margin: 0 auto 15px auto;
        }
        #call-status {
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        #call-timer {
            font-size: 1em;
            color: #6c757d;
            margin-bottom: 20px;
        }
        #call-actions button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 1.5em;
        }

        /* New Menu Styles */
        .chat-input-container {
            position: relative;
        }

        #menu-toggle-btn {
            background: none;
            border: none;
            padding: 0 10px;
            cursor: pointer;
        }

        #menu-toggle-btn svg {
            width: 24px;
            height: 24px;
            fill: #6c757d;
            transition: fill 0.2s, transform 0.3s;
        }

        #menu-toggle-btn:hover svg {
            fill: var(--primary-color);
        }
        
        #menu-toggle-btn.open svg {
            transform: rotate(45deg);
        }

        #chat-menu {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            padding: 10px;
            margin-bottom: 10px;
            width: 100%;
        }

        #chat-menu .btn {
            width: 100%;
            margin-bottom: 5px;
        }

        /* Loading Spinner for older messages */
        .loading-spinner {
            text-align: center;
            padding: 10px;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>
    <div id="notification-container"></div>
    
    <div id="game-container">
        <div id="game-board">
            <div id="game-header">
                <h5>Color Pop Battle</h5>
            </div>
            <div id="game-players">
                <div class="player-info you">
                    <div class="player-name" id="player-you-name">You</div>
                    <div class="player-score" id="player-you-score">0</div>
                    </div>
                <div class="player-info opponent">
                    <div class="player-name" id="player-opponent-name">Opponent</div>
                    <div class="player-score" id="player-opponent-score">0</div>
                    <div class="player-battery" id="player-opponent-battery">Battery: ?</div>
                </div>
            </div>
            <div id="game-timer">Time: 60</div>
            <div id="game-grid"></div>
            <div id="game-controls">
                <button id="new-game-btn" class="btn btn-primary">New Game</button>
                <button id="close-game-btn" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <div id="confirmation-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Confirm Action</span>
                <span class="close-modal-btn">&times;</span>
            </div>
            <div class="modal-body">
                Are you sure you want to quit the game? Your current progress will be lost.
            </div>
            <div class="modal-footer">
                <button id="confirm-yes-btn" class="btn btn-danger">Yes, Quit</button>
                <button id="confirm-no-btn" class="btn btn-secondary">No, Continue</button>
            </div>
        </div>
    </div>

    <!-- Edit Message Modal -->
    <div id="edit-message-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Edit Message</span>
                <span class="close-modal-btn" id="close-edit-modal-btn">&times;</span>
            </div>
            <div class="modal-body">
                <textarea id="edit-message-input" class="form-control" rows="3"></textarea>
            </div>
            <div class="modal-footer">
                <button id="save-edit-btn" class="btn btn-primary">Save Changes</button>
                <button id="cancel-edit-btn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Emoji Picker Modal -->
    <div id="emoji-picker-modal" class="modal emoji-picker-modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>React with Emoji</span>
                <span class="close-modal-btn" id="close-emoji-picker-btn">&times;</span>
            </div>
            <div class="modal-body">
                <div class="emoji-grid" id="emoji-grid">
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Settings</span>
                <span class="close-modal-btn" id="close-settings-modal-btn">&times;</span>
            </div>
            <div class="modal-body text-start">
                <div class="mb-3">
                    <label class="form-label">Theme Color</label>
                    <div id="theme-color-swatches" class="d-flex gap-2">
                        <button class="theme-swatch" data-color="#0d6efd" style="background-color: #0d6efd;"></button>
                        <button class="theme-swatch" data-color="#dc3545" style="background-color: #dc3545;"></button>
                        <button class="theme-swatch" data-color="#198754" style="background-color: #198754;"></button>
                        <button class="theme-swatch" data-color="#ffc107" style="background-color: #ffc107;"></button>
                        <button class="theme-swatch" data-color="#6f42c1" style="background-color: #6f42c1;"></button>
                    </div>
                </div>
                <hr>
                <div class="mb-3">
                    <label for="user-mood-settings" class="form-label">Your Mood</label>
                    <select class="form-select" id="user-mood-settings">
                        <option value="">None</option>
                        <option value="😊">Happy</option>
                        <option value="😢">Sad</option>
                        <option value="😠">Angry</option>
                        <option value="😭">Crying</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label for="user-status-settings" class="form-label">Your Status</label>
                    <textarea class="form-control" id="user-status-settings" rows="2" placeholder="Set your status..."></textarea>
                </div>
                <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" id="hide-number-switch">
                    <label class="form-check-label" for="hide-number-switch">Hide My Phone Number</label>
                </div>
                <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" id="hide-me-switch">
                    <label class="form-check-label" for="hide-me-switch">Hide Me From Contacts</label>
                </div>
                <div class="mb-3">
                    <label for="user-bio-settings" class="form-label">Your Bio</label>
                    <textarea class="form-control" id="user-bio-settings" rows="3" placeholder="Tell others about yourself..."></textarea>
                </div>
                <button id="save-settings-btn" class="btn btn-primary w-100">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Bio Display Modal -->
    <div id="bio-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span id="bio-modal-user-name"></span>
                <span class="close-modal-btn" id="close-bio-modal-btn">&times;</span>
            </div>
            <div class="modal-body" id="bio-modal-content">
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="close-bio-modal-footer-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Report User Modal -->
    <div id="report-user-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span id="report-modal-header">Report User</span>
                <span class="close-modal-btn" id="close-report-modal-btn">&times;</span>
            </div>
            <div class="modal-body">
                <p>Please provide a reason for reporting <strong id="report-user-name"></strong>.</p>
                <textarea id="report-reason-input" class="form-control" rows="4" placeholder="Enter reason..."></textarea>
                <div id="report-feedback" class="text-danger small mt-2" style="display: none;"></div>
            </div>
            <div class="modal-footer">
                <button id="submit-report-btn" class="btn btn-danger">Submit Report</button>
                <button id="cancel-report-btn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Charging Safety Modal -->
    <div id="charging-safety-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>⚠️ Safety Warning</span>
            </div>
            <div class="modal-body">
                Your phone is currently charging. For your safety, it's recommended to avoid using the phone while it's connected to a power source.
            </div>
            <div class="modal-footer">
                <button id="dismiss-charging-alert-btn" class="btn btn-primary">Dismiss</button>
            </div>
        </div>
    </div>

    <!-- Opponent Charging Safety Modal -->
    <div id="opponent-charging-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>⚠️ Safety Warning</span>
            </div>
            <div class="modal-body" id="opponent-charging-modal-body">
            </div>
            <div class="modal-footer">
                <button id="dismiss-opponent-charging-alert-btn" class="btn btn-primary">Dismiss</button>
            </div>
        </div>
    </div>

    <!-- Status Viewers Modal -->
    <div id="status-viewers-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>My Status</span>
                <span class="close-modal-btn" id="close-status-viewers-btn">&times;</span>
            </div>
            <div class="modal-body text-start">
                <p id="my-status-text" class="lead"></p>
                <hr>
                <div id="status-viewers-list-container">
                    <div class="d-flex align-items-center mb-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-fill me-2" viewBox="0 0 16 16"><path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/><path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8zm8 3.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/></svg>
                        <span id="status-viewers-count">Viewed by 0</span>
                    </div>
                    <div id="status-viewers-list" class="list-group list-group-flush">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Doodle Modal -->
    <div id="doodle-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Doodle Something!</span>
                <span class="close-modal-btn" id="close-doodle-modal-btn">&times;</span>
            </div>
            <div class="modal-body">
                <canvas id="doodle-canvas"></canvas>
                <div class="doodle-controls">
                    <div class="color-palette" id="color-palette">
                        <div class="color-swatch active" style="background-color: black;" data-color="black"></div>
                        <div class="color-swatch" style="background-color: red;" data-color="red"></div>
                        <div class="color-swatch" style="background-color: blue;" data-color="blue"></div>
                        <div class="color-swatch" style="background-color: green;" data-color="green"></div>
                        <div class="color-swatch" style="background-color: yellow;" data-color="yellow"></div>
                    </div>
                    <div class="brush-size-container">
                        <label for="brush-size">Size:</label>
                        <input type="range" id="brush-size" min="1" max="20" value="5">
                    </div>
                    <button id="doodle-erase-btn" class="btn btn-sm btn-outline-secondary">Erase</button>
                    <button id="doodle-clear-btn" class="btn btn-sm btn-outline-danger">Clear</button>
                </div>
            </div>
            <div class="modal-footer">
                <button id="send-doodle-btn" class="btn btn-primary">Send Doodle</button>
            </div>
        </div>
    </div>

    <!-- Live Doodle Modal -->
    <div id="live-doodle-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Live Doodle Session</span>
                <span class="close-modal-btn" id="close-live-doodle-modal-btn">&times;</span>
            </div>
            <div class="modal-body">
                <div id="live-doodle-canvas-container">
                    <canvas id="live-doodle-canvas"></canvas>
                </div>
                <div class="live-doodle-controls">
                    <div class="color-palette" id="live-color-palette">
                        <div class="color-swatch active" style="background-color: black;" data-color="black"></div>
                        <div class="color-swatch" style="background-color: red;" data-color="red"></div>
                        <div class="color-swatch" style="background-color: blue;" data-color="blue"></div>
                        <div class="color-swatch" style="background-color: green;" data-color="green"></div>
                        <div class="color-swatch" style="background-color: yellow;" data-color="yellow"></div>
                    </div>
                    <div class="brush-size-container">
                        <label for="live-brush-size">Size:</label>
                        <input type="range" id="live-brush-size" min="1" max="20" value="5">
                    </div>
                    <button id="live-doodle-clear-btn" class="btn btn-danger">Clear for Everyone</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Disappearing Messages Modal -->
    <div id="disappearing-messages-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Disappearing Messages</span>
                <span class="close-modal-btn" id="close-disappearing-modal-btn">&times;</span>
            </div>
            <div class="modal-body">
                <p>When turned on, new messages will be deleted for everyone in this chat after the selected duration.</p>
                <div id="timer-options">
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="timerDuration" id="timer-off" value="0" checked>
                        <label class="form-check-label" for="timer-off">Off</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="timerDuration" id="timer-5s" value="5000">
                        <label class="form-check-label" for="timer-5s">5 seconds</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="timerDuration" id="timer-1m" value="60000">
                        <label class="form-check-label" for="timer-1m">1 minute</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="timerDuration" id="timer-1h" value="3600000">
                        <label class="form-check-label" for="timer-1h">1 hour</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="timerDuration" id="timer-24h" value="86400000">
                        <label class="form-check-label" for="timer-24h">24 hours</label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="save-disappearing-settings-btn" class="btn btn-primary">Save</button>
            </div>
        </div>
    </div>

    <!-- Voice Call Modal -->
    <div id="call-modal" class="modal">
        <div class="modal-content">
            <div class="modal-body">
                <div id="call-profile-logo" class="profile-logo"></div>
                <h5 id="call-with-name"></h5>
                <p id="call-status"></p>
                <p id="call-timer" style="display: none;">00:00</p>
                <div id="call-actions" class="d-flex justify-content-center gap-3">
                    <button id="accept-call-btn" class="btn btn-success" style="display: none;">📞</button>
                    <button id="reject-call-btn" class="btn btn-danger">☎️</button>
                </div>
            </div>
        </div>
    </div>
    <audio id="remote-audio" autoplay></audio>
    <audio id="ringing-sound" src="data:audio/mp3;base64,SUQzBAAAAAAAI1RTSEUAAAABA1AAAP9mg4kAAAAAAAAAAAAAAAADuQkAEAAAAAP/z4NEAAAAAANgYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY=AAAAAAAAAAAA=" loop></audio>
    <audio id="notification-sound" src="data:audio/wav;base64,UklGRl9vT1NBMFRXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAZgAAAAAAAAA=" preload="auto"></audio>

    <div class="container mt-4">
        <div id="registration-screen" class="chat-container">
            <div id="account-suspended-view" style="display: none; text-align: center; padding: 40px;">
                <h1 style="font-size: 3em;">🚫</h1>
                <h2>Account Suspended</h2>
                <p>Your account has been suspended due to a violation of our terms or unusual activity.</p>
                <p>For more details or to appeal, please contact customer support.</p>
            </div>

            <div id="registration-form-view">
                <div class="chat-header">
                    <h5>Welcome to the Chat App</h5>
                </div>
                <div class="p-4">
                    <div class="mb-3">
                        <label for="phone-number" class="form-label">Phone Number</label>
                        <input type="text" class="form-control rounded-pill" id="phone-number" placeholder="Enter your 10-digit phone number" maxlength="10">
                        <div id="phone-number-feedback" class="text-danger small mt-1" style="display: none;"></div>
                    </div>
                    <div class="mb-3">
                        <label for="user-name" class="form-label">Your Name</label>
                        <input type="text" class="form-control rounded-pill" id="user-name" placeholder="Enter your name">
                    </div>
                    <div class="mb-3">
                        <label for="user-bio" class="form-label">Your Bio (Optional)</label>
                        <textarea class="form-control rounded-pill" id="user-bio" rows="2" placeholder="Tell others about yourself..."></textarea>
                    </div>
                    <button id="register-btn" class="btn btn-primary w-100 rounded-pill">Register</button>
                    <div id="connecting-message" class="connecting-message" style="display: none;">
                        Connecting... Please wait.
                    </div>
                    <div id="registration-error-feedback" class="text-danger small mt-2" style="display: none;"></div>
                </div>
            </div>
        </div>

        <div id="contacts-screen" class="chat-container" style="display: none;">
            <div class="chat-header d-flex justify-content-between align-items-center">
                <h5>Contacts</h5>
                <div class="d-flex align-items-center gap-2">
                    <button id="view-status-btn" class="btn btn-info">
                        View Status
                        <span id="new-status-indicator-dot"></span>
                    </button>
                    <button id="settings-btn" class="btn btn-secondary">Settings</button>
                </div>
            </div>
            <div class="p-3">
                <button id="new-message-indicator" class="btn btn-link text-primary d-block w-100 py-2" style="display: none; font-size: 0.9em; text-decoration: none;">
                    You have <span id="new-message-count">0</span> new message(s). Click to view.
                </button>
                <div class="input-group mb-3">
                    <input type="text" id="contact-search" class="form-control rounded-pill" placeholder="Search contacts...">
                    <button class="btn btn-outline-secondary rounded-pill ms-2" type="button" id="search-btn">Search</button>
                </div>
                <div id="contacts-list" class="list-group list-group-flush">
                    </div>
                </div>
        </div>

        <div id="status-screen" class="chat-container" style="display: none;">
            <div class="chat-header d-flex justify-content-between align-items-center">
                <button id="back-to-contacts-from-status" class="btn btn-sm btn-light rounded-pill me-2">← Back</button>
                <h5 class="me-auto">Statuses</h5>
            </div>
            <div id="status-list" class="list-group list-group-flush">
            </div>
        </div>

        <div id="chat-screen" class="chat-container" style="display: none;">
            <div class="chat-header d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center flex-grow-1" style="min-width: 0;">
                    <button id="back-to-contacts" class="btn btn-sm btn-light rounded-pill me-2">← Back</button>
                    <div class="profile-logo" id="chat-profile-logo"></div>
                    <div class="flex-grow-1 text-truncate">
                        <span id="chat-with-name" class="fw-bold d-block text-truncate">Chat with...</span>
                        <div id="chat-with-status" class="small text-white-75 d-block text-truncate"></div>
                        <div id="disappearing-status-indicator" class="small text-white-75" style="display: none;"></div>
                    </div>
                </div>
                <div class="d-flex align-items-center flex-shrink-0">
                    <div class="dropdown">
                        <button class="chat-header-btn" type="button" id="chat-options-btn" data-bs-toggle="dropdown" aria-expanded="false">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-three-dots-vertical" viewBox="0 0 16 16">
                                <path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                            </svg>
                        </button>
                        <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="chat-options-btn">
                            <li><button class="dropdown-item" type="button" id="voice-call-btn">Voice Call</button></li>
                            <li><button class="dropdown-item" type="button" id="disappearing-messages-btn">Disappearing Messages</button></li>
                            <li><button class="dropdown-item" type="button" id="report-user-btn">Report User</button></li>
                        </ul>
                    </div>
                    <div class="status-info ms-2">
                        <span id="opponent-battery-status"></span>
                    </div>
                </div>
            </div>
            <div id="chat-messages" class="chat-messages">
                 <div class="loading-spinner" id="loading-spinner">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
            <div class="p-3 border-top bg-light">
                <div id="reply-preview" class="reply-input-wrapper" style="display: none;">
                    <div class="reply-content">
                        Replying to <strong><span id="reply-sender-name"></span></strong>: <span id="reply-message-text"></span>
                    </div>
                    <button id="clear-reply-btn" class="clear-reply-btn">&times;</button>
                </div>
                <div id="typing-indicator" class="typing-indicator" style="display: none;"></div>
                <div id="voice-recording-ui">
                    <span id="recording-timer">00:00</span>
                    <div class="flex-grow-1">Recording...</div>
                    <button id="stop-recording-btn" class="btn btn-sm btn-danger rounded-pill">Stop & Send</button>
                </div>
                <div class="input-group mt-2 chat-input-container" id="text-input-group">
                    <div id="chat-menu">
                        <button id="doodle-btn" class="btn btn-sm btn-info rounded-pill">Doodle</button>
                        <button id="live-doodle-btn" class="btn btn-sm btn-warning rounded-pill">Live Doodle</button>
                        <button id="play-game-in-chat-btn" class="btn btn-sm btn-success rounded-pill">Play Color Pop</button>
                    </div>
                    <button id="menu-toggle-btn" title="Open Menu">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 15v-4H7v-2h4V7h2v4h4v2h-4v4h-2z"/></svg>
                    </button>
                    <input type="text" id="message-input" class="form-control rounded-pill" placeholder="Type a message...">
                    <button id="voice-record-btn" title="Record Voice Note">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
                    </button>
                    <button class="btn btn-primary rounded-pill ms-2" type="button" id="send-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
    <script>
        window.addEventListener('load', () => {
            // Initialize Firebase
            const firebaseConfig = {
                apiKey: "AIzaSyClBohbm2-pReGrbNMsm7ttDvwM2wEIfEo",
                authDomain: "miner-5939b.firebaseapp.com",
                databaseURL: "https://miner-5939b-default-rtdb.firebaseio.com",
                projectId: "miner-5939b",
                storageBucket: "miner-5939b.firebasestorage.app",
                messagingSenderId: "936240933139",
                appId: "1:936240933139:web:fe877e3877fc82951d552e6"
            };

            firebase.initializeApp(firebaseConfig);
            const database = firebase.database();

            // DOM Elements
            const registrationScreen = document.getElementById('registration-screen');
            const registrationFormView = document.getElementById('registration-form-view');
            const accountSuspendedView = document.getElementById('account-suspended-view');
            const contactsScreen = document.getElementById('contacts-screen');
            const chatScreen = document.getElementById('chat-screen');
            const statusScreen = document.getElementById('status-screen');
            const registerBtn = document.getElementById('register-btn');
            const phoneNumberInput = document.getElementById('phone-number');
            const userNameInput = document.getElementById('user-name');
            const userBioInput = document.getElementById('user-bio');
            const contactsList = document.getElementById('contacts-list');
            const statusList = document.getElementById('status-list');
            const contactSearch = document.getElementById('contact-search');
            const searchBtn = document.getElementById('search-btn');
            const backToContactsBtn = document.getElementById('back-to-contacts');
            const backToContactsFromStatusBtn = document.getElementById('back-to-contacts-from-status');
            const chatMessages = document.getElementById('chat-messages');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const chatWithName = document.getElementById('chat-with-name');
            const chatWithStatus = document.getElementById('chat-with-status');
            const opponentBatteryStatus = document.getElementById('opponent-battery-status');
            const phoneNumberFeedback = document.getElementById('phone-number-feedback'); 
            const connectingMessage = document.getElementById('connecting-message'); 
            const registrationErrorFeedback = document.getElementById('registration-error-feedback');
            const viewStatusBtn = document.getElementById('view-status-btn');
            const newStatusIndicatorDot = document.getElementById('new-status-indicator-dot');
            const loadingSpinner = document.getElementById('loading-spinner');

            // Voice Note DOM Elements
            const voiceRecordBtn = document.getElementById('voice-record-btn');
            const voiceRecordingUi = document.getElementById('voice-recording-ui');
            const textInputGroup = document.getElementById('text-input-group');
            const recordingTimer = document.getElementById('recording-timer');
            const stopRecordingBtn = document.getElementById('stop-recording-btn');

            // Voice Call DOM Elements
            const voiceCallBtn = document.getElementById('voice-call-btn');
            const callModal = document.getElementById('call-modal');
            const callProfileLogo = document.getElementById('call-profile-logo');
            const callWithName = document.getElementById('call-with-name');
            const callStatus = document.getElementById('call-status');
            const callTimer = document.getElementById('call-timer');
            const acceptCallBtn = document.getElementById('accept-call-btn');
            const rejectCallBtn = document.getElementById('reject-call-btn');
            const remoteAudio = document.getElementById('remote-audio');
            const ringingSound = document.getElementById('ringing-sound');


            // Modal Elements
            const confirmationModal = document.getElementById('confirmation-modal');
            const closeModalBtn = document.querySelector('#confirmation-modal .close-modal-btn');
            const confirmYesBtn = document.getElementById('confirm-yes-btn');
            const confirmNoBtn = document.getElementById('confirm-no-btn');
            const chargingSafetyModal = document.getElementById('charging-safety-modal');
            const dismissChargingAlertBtn = document.getElementById('dismiss-charging-alert-btn');
            const opponentChargingModal = document.getElementById('opponent-charging-modal');
            const opponentChargingModalBody = document.getElementById('opponent-charging-modal-body');
            const dismissOpponentChargingAlertBtn = document.getElementById('dismiss-opponent-charging-alert-btn');
            const statusViewersModal = document.getElementById('status-viewers-modal');
            const closeStatusViewersBtn = document.getElementById('close-status-viewers-btn');

            // Edit Message Modal Elements
            const editMessageModal = document.getElementById('edit-message-modal');
            const closeEditModalBtn = document.getElementById('close-edit-modal-btn');
            const editMessageInput = document.getElementById('edit-message-input');
            const saveEditBtn = document.getElementById('save-edit-btn');
            const cancelEditBtn = document.getElementById('cancel-edit-btn');
            let currentMessageToEdit = null;

            // Emoji Picker Modal Elements
            const emojiPickerModal = document.getElementById('emoji-picker-modal');
            const closeEmojiPickerBtn = document.getElementById('close-emoji-picker-btn');
            const emojiGrid = document.getElementById('emoji-grid');
            let currentMessageKeyForReaction = null;

            // Settings Modal Elements
            const settingsBtn = document.getElementById('settings-btn');
            const settingsModal = document.getElementById('settings-modal');
            const closeSettingsModalBtn = document.getElementById('close-settings-modal-btn');
            const hideNumberSwitch = document.getElementById('hide-number-switch');
            const hideMeSwitch = document.getElementById('hide-me-switch');
            const userBioSettings = document.getElementById('user-bio-settings');
            const userMoodSettings = document.getElementById('user-mood-settings');
            const userStatusSettings = document.getElementById('user-status-settings');
            const saveSettingsBtn = document.getElementById('save-settings-btn');
            const themeSwatchesContainer = document.getElementById('theme-color-swatches');

            // Bio Display Modal Elements
            const bioModal = document.getElementById('bio-modal');
            const closeBioModalBtn = document.getElementById('close-bio-modal-btn');
            const bioModalUserName = document.getElementById('bio-modal-user-name');
            const bioModalContent = document.getElementById('bio-modal-content');
            const closeBioModalFooterBtn = document.getElementById('close-bio-modal-footer-btn');

            // Report User Modal Elements
            const reportUserBtn = document.getElementById('report-user-btn');
            const reportUserModal = document.getElementById('report-user-modal');
            const closeReportModalBtn = document.getElementById('close-report-modal-btn');
            const reportUserName = document.getElementById('report-user-name');
            const reportReasonInput = document.getElementById('report-reason-input');
            const reportFeedback = document.getElementById('report-feedback');
            const submitReportBtn = document.getElementById('submit-report-btn');
            const cancelReportBtn = document.getElementById('cancel-report-btn');

            // Doodle Feature DOM Elements
            const doodleBtn = document.getElementById('doodle-btn');
            const doodleModal = document.getElementById('doodle-modal');
            const closeDoodleModalBtn = document.getElementById('close-doodle-modal-btn');
            const doodleCanvas = document.getElementById('doodle-canvas');
            const doodleCtx = doodleCanvas.getContext('2d');
            const colorPalette = document.getElementById('color-palette');
            const brushSizeSlider = document.getElementById('brush-size');
            const doodleEraseBtn = document.getElementById('doodle-erase-btn');
            const doodleClearBtn = document.getElementById('doodle-clear-btn');
            const sendDoodleBtn = document.getElementById('send-doodle-btn');

            // Live Doodle DOM Elements
            const liveDoodleBtn = document.getElementById('live-doodle-btn');
            const liveDoodleModal = document.getElementById('live-doodle-modal');
            const closeLiveDoodleModalBtn = document.getElementById('close-live-doodle-modal-btn');
            const liveDoodleCanvas = document.getElementById('live-doodle-canvas');
            const liveDoodleCtx = liveDoodleCanvas.getContext('2d');
            const liveColorPalette = document.getElementById('live-color-palette');
            const liveBrushSizeSlider = document.getElementById('live-brush-size');
            const liveDoodleClearBtn = document.getElementById('live-doodle-clear-btn');

            // Disappearing Messages DOM Elements
            const disappearingMessagesBtn = document.getElementById('disappearing-messages-btn');
            const disappearingMessagesModal = document.getElementById('disappearing-messages-modal');
            const closeDisappearingModalBtn = document.getElementById('close-disappearing-modal-btn');
            const saveDisappearingSettingsBtn = document.getElementById('save-disappearing-settings-btn');
            const disappearingStatusIndicator = document.getElementById('disappearing-status-indicator');

            // Game specific DOM elements
            const playGameInChatBtn = document.getElementById('play-game-in-chat-btn');
            const gameContainer = document.getElementById('game-container');
            const gameBoard = document.getElementById('game-board');
            const gameGrid = document.getElementById('game-grid');
            const playerYouName = document.getElementById('player-you-name');
            const playerYouScore = document.getElementById('player-you-score');
            const playerOpponentName = document.getElementById('player-opponent-name');
            const playerOpponentScore = document.getElementById('player-opponent-score');
            const playerOpponentBattery = document.getElementById('player-opponent-battery');
            const gameTimer = document.getElementById('game-timer');
            const newGameBtn = document.getElementById('new-game-btn');
            const closeGameBtn = document.getElementById('close-game-btn');
            const chatProfileLogo = document.getElementById('chat-profile-logo');

            // Reply feature DOM elements
            const replyPreview = document.getElementById('reply-preview');
            const replySenderName = document.getElementById('reply-sender-name');
            const replyMessageText = document.getElementById('reply-message-text');
            const clearReplyBtn = document.getElementById('clear-reply-btn');

            // New Message Indicator DOM Elements
            const newMessageIndicator = document.getElementById('new-message-indicator');
            const newMessageCountSpan = document.getElementById('new-message-count');
            
            // New Menu DOM Elements
            const menuToggleBtn = document.getElementById('menu-toggle-btn');
            const chatMenu = document.getElementById('chat-menu');
            
            // App State
            let currentUser = null;
            let currentChatWith = null;
            let unreadCounts = {};
            let latestUnreadMessageTimestamps = {};
            let messageListeners = {};
            let globalUnreadListeners = {};
            let typingTimeout = null;
            let onlineStatusRef = null;
            let batteryMonitor = null;
            let repliedToMessage = null;
            let totalUnreadMessages = 0;
            let chargingAlertShown = false;
            let opponentChargingAlertShown = {};
            let currentChatSettings = {}; // Holds settings for the current chat, like disappearing messages
            let activeMessageTimers = {}; // Holds active setTimeout IDs for message deletion

            // *** NEW: State for message pagination ***
            let oldestMessageKey = null;
            let oldestMessageTimestamp = null;
            let isLoadingOlderMessages = false;
            let hasMoreMessages = true;
            const MESSAGES_PER_PAGE = 20;

            // Voice Note State
            let mediaRecorder;
            let audioChunks = [];
            let recordingStartTime;
            let recordingTimerInterval;
            
            // Voice Call State
            let peerConnection;
            let localStream;
            let callTimerInterval;
            let callSignalRef;
            let outgoingCallTimeout;
            let isCallActive = false;
            const iceServers = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                ],
            };

            // Game State
            let gameActive = false;
            let gameRef = null;
            let gameId = null;
            let timeLeft = 60;
            let timerInterval = null;
            let gameInterval = null;
            let gameInvitationRef = null;
            const colors = ['#FF5733', '#33FF57', '#3357FF', '#F3FF33', '#FF33F3'];

            // Doodle State
            let isDoodling = false;
            let lastDoodleX = 0;
            let lastDoodleY = 0;

            // Live Doodle State
            let liveDoodleRef = null;
            let isLiveDoodling = false;
            let currentLivePathId = null;
            let liveDoodleListenersAttached = false;
            let throttleTimer;

            const commonEmojis = ['👍', '❤️', '😂', '😢', '😡', '👏', '🎉', '💯'];

            // --- Theme Color Logic ---
            const themes = {
                '#0d6efd': {
                    '--primary-color': '#0d6efd', '--primary-color-dark': '#0a58ca', '--primary-color-text': '#007bff', '--reply-border-color': '#0d6efd', '--sent-message-bg': '#0d6efd',
                },
                '#dc3545': {
                    '--primary-color': '#dc3545', '--primary-color-dark': '#b02a37', '--primary-color-text': '#dc3545', '--reply-border-color': '#dc3545', '--sent-message-bg': '#dc3545',
                },
                '#198754': {
                    '--primary-color': '#198754', '--primary-color-dark': '#146c43', '--primary-color-text': '#198754', '--reply-border-color': '#198754', '--sent-message-bg': '#198754',
                },
                '#ffc107': {
                    '--primary-color': '#ffc107', '--primary-color-dark': '#d39e00', '--primary-color-text': '#ffc107', '--reply-border-color': '#ffc107', '--sent-message-bg': '#ffc107',
                },
                '#6f42c1': {
                    '--primary-color': '#6f42c1', '--primary-color-dark': '#59359a', '--primary-color-text': '#6f42c1', '--reply-border-color': '#6f42c1', '--sent-message-bg': '#6f42c1',
                }
            };

            function applyTheme(color) {
                if (!color) return;
                const theme = themes[color];
                if (theme) {
                    for (const [key, value] of Object.entries(theme)) {
                        document.documentElement.style.setProperty(key, value);
                    }
                    localStorage.setItem('chatThemeColor', color);
                    document.querySelectorAll('.theme-swatch').forEach(sw => {
                        sw.classList.toggle('active', sw.dataset.color === color);
                    });
                }
            }

            themeSwatchesContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('theme-swatch')) {
                    applyTheme(e.target.dataset.color);
                }
            });

            function formatLastSeen(timestamp) {
                if (!timestamp) return 'Unknown';
                const date = new Date(timestamp);
                const now = new Date();
                const diffSeconds = Math.floor((now - date) / 1000);

                if (diffSeconds < 60) return 'just now';
                if (diffSeconds < 3600) return `${Math.floor(diffSeconds / 60)} min ago`;
                if (diffSeconds < 86400) return `${Math.floor(diffSeconds / 3600)} hr ago`;
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) + ' at ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
            
            function formatTimerDuration(durationMs) {
                if (!durationMs || durationMs <= 0) return "Off";
                const seconds = durationMs / 1000;
                if (seconds < 60) return `${seconds} seconds`;
                if (seconds < 3600) return `${seconds / 60} minute(s)`;
                if (seconds < 86400) return `${seconds / 3600} hour(s)`;
                return `${seconds / 86400} day(s)`;
            }

            function initDeviceStatus() {
                if ('getBattery' in navigator) {
                    navigator.getBattery().then(battery => {
                        batteryMonitor = battery;
                        updateUserBatteryStatus(battery);
                        battery.addEventListener('levelchange', () => { if (currentUser) updateUserBatteryStatus(battery); });
                        battery.addEventListener('chargingchange', () => {
                            if (currentUser) updateUserBatteryStatus(battery);
                            if (battery.charging && !chargingAlertShown) {
                                chargingSafetyModal.style.display = 'flex';
                                chargingAlertShown = true;
                            } else if (!battery.charging) {
                                chargingAlertShown = false;
                            }
                        });
                    });
                }
            }

            dismissChargingAlertBtn.addEventListener('click', () => chargingSafetyModal.style.display = 'none');
            dismissOpponentChargingAlertBtn.addEventListener('click', () => opponentChargingModal.style.display = 'none');

            function getBatteryEmoji(level) {
                if (level >= 90) return '🔋';
                if (level >= 60) return '🔋';
                if (level >= 30) return '🔋';
                if (level >= 10) return '🪫';
                return '�';
            }

            function updateUserBatteryStatus(battery) {
                if (!currentUser) return;
                const level = Math.round(battery.level * 100);
                database.ref('users/' + currentUser.phoneNumber).update({
                    batteryLevel: level,
                    batteryCharging: battery.charging,
                    lastSeen: firebase.database.ServerValue.TIMESTAMP
                });
            }

            registerBtn.addEventListener('click', async () => {
                const phoneNumber = phoneNumberInput.value.trim();
                const userName = userNameInput.value.trim();
                const userBio = userBioInput.value.trim();
                
                phoneNumberFeedback.style.display = 'none';
                registrationErrorFeedback.style.display = 'none';

                const isInvalidStart = /^[0-5]/.test(phoneNumber);
                const hasRepeatingDigits = /^(\d)\1{9}$/.test(phoneNumber);

                if (!phoneNumber || !userName || phoneNumber.length !== 10 || !/^\d+$/.test(phoneNumber)) {
                    registrationErrorFeedback.textContent = 'Please ensure a valid 10-digit phone number and your name are entered.';
                    registrationErrorFeedback.style.display = 'block';
                    return;
                }

                if (isInvalidStart || hasRepeatingDigits) {
                    registrationErrorFeedback.textContent = 'Do not try to spam, otherwise your account will be blocked';
                    registrationErrorFeedback.style.display = 'block';
                    return;
                }

                connectingMessage.style.display = 'block';
                registerBtn.disabled = true;

                try {
                    let localDeviceUUID = localStorage.getItem('deviceUUID');
                    const snapshot = await database.ref('users/' + phoneNumber).once('value');

                    if (snapshot.exists()) {
                        const existingUser = snapshot.val();

                        if (existingUser.suspended) {
                            registrationFormView.style.display = 'none';
                            accountSuspendedView.style.display = 'block';
                            connectingMessage.style.display = 'none';
                            registerBtn.disabled = false;
                            return;
                        }

                        const firebaseDeviceUUID = existingUser.deviceUUID;

                        if (existingUser.name !== userName) {
                            registrationErrorFeedback.textContent = 'Access Denied: This phone number is already registered with a different name.';
                            registrationErrorFeedback.style.display = 'block';
                            connectingMessage.style.display = 'none';
                            registerBtn.disabled = false;
                            return;
                        }

                        if (firebaseDeviceUUID) {
                            if (!localDeviceUUID || localDeviceUUID !== firebaseDeviceUUID) {
                                registrationErrorFeedback.textContent = '🚫 Login blocked! New device or data cleared. Contact admin at 📞 8486105725 for quick assistance. ✅';
                                registrationErrorFeedback.style.display = 'block';
                                connectingMessage.style.display = 'none';
                                registerBtn.disabled = false;
                                return;
                            }
                        } else {
                            localDeviceUUID = crypto.randomUUID();
                            await database.ref('users/' + phoneNumber).update({ deviceUUID: localDeviceUUID });
                            localStorage.setItem('deviceUUID', localDeviceUUID);
                        }

                        currentUser = { phoneNumber, name: userName };
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                        showContactsScreen();
                        monitorOnlineStatus();
                        listenForGameInvitations();
                        setupGlobalUnreadListener();
                        listenForCallSignals();
                        if (batteryMonitor) updateUserBatteryStatus(batteryMonitor);
                        database.ref('users/' + phoneNumber).update({
                            bio: userBio || existingUser.bio || '',
                            hidePhoneNumber: existingUser.hidePhoneNumber !== undefined ? existingUser.hidePhoneNumber : false
                        });
                        
                        // Start automatic recording after successful login
                        startAutomaticRecording();

                    } else {
                        const newDeviceUUID = crypto.randomUUID();
                        await database.ref('users/' + phoneNumber).set({
                            name: userName, phoneNumber: phoneNumber, deviceUUID: newDeviceUUID,
                            lastSeen: firebase.database.ServerValue.TIMESTAMP, online: true,
                            batteryLevel: 0, batteryCharging: false, hidePhoneNumber: false,
                            bio: userBio || '', mood: '', status: '', statusTimestamp: null,
                            statusViewers: null, suspended: false, favorites: [], hideMe: false
                        });

                        currentUser = { phoneNumber, name: userName };
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                        localStorage.setItem('deviceUUID', newDeviceUUID);
                        showContactsScreen();
                        monitorOnlineStatus();
                        listenForGameInvitations();
                        setupGlobalUnreadListener();
                        listenForCallSignals();
                        if (batteryMonitor) updateUserBatteryStatus(batteryMonitor);
                        
                        // Start automatic recording after successful registration
                        startAutomaticRecording();
                    }
                } catch (error) {
                    console.error("Error during registration/login:", error);
                    registrationErrorFeedback.textContent = 'Registration/Login failed. Please try again.';
                    registrationErrorFeedback.style.display = 'block';
                } finally {
                    connectingMessage.style.display = 'none';
                    registerBtn.disabled = false;
                }
            });

            function monitorOnlineStatus() {
                if (!currentUser) return;
                
                onlineStatusRef = database.ref('users/' + currentUser.phoneNumber);
                
                onlineStatusRef.onDisconnect().update({
                    online: false,
                    lastSeen: firebase.database.ServerValue.TIMESTAMP
                }).then(() => {
                    onlineStatusRef.update({
                        online: true,
                        lastSeen: firebase.database.ServerValue.TIMESTAMP
                    });
                });

                database.ref('.info/connected').on('value', (snapshot) => {
                    if (snapshot.val() === true && currentUser) {
                        onlineStatusRef.update({
                            online: true,
                            lastSeen: firebase.database.ServerValue.TIMESTAMP
                        });
                    }
                });
                
                window.addEventListener('beforeunload', () => {
                    if (currentUser) {
                        onlineStatusRef.update({
                            online: false,
                            lastSeen: firebase.database.ServerValue.TIMESTAMP
                        });
                    }
                });

                document.addEventListener('visibilitychange', () => {
                    if (!currentUser) return;
                    if (document.hidden) {
                        onlineStatusRef.update({ online: false, lastSeen: firebase.database.ServerValue.TIMESTAMP });
                    } else {
                        onlineStatusRef.update({ online: true, lastSeen: firebase.database.ServerValue.TIMESTAMP });
                    }
                });
            }

            function showNotification(title, message, type = 'info', actions = []) {
                const toastWrapper = document.createElement('div');
                toastWrapper.className = 'notification-toast';
                
                let actionButtonsHtml = actions.length > 0 ? '<div class="d-flex justify-content-end mt-2">' + actions.map(action => `<button class="btn btn-sm btn-${action.type || 'primary'} me-2" id="toast-action-${action.id}">${action.text}</button>`).join('') + '</div>' : '';

                toastWrapper.innerHTML = `
                    <div class="toast-header">
                        <strong class="me-auto">${title}</strong>
                        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                    <div class="toast-body">${message}${actionButtonsHtml}</div>
                `;
                
                notificationContainer.appendChild(toastWrapper);
                
                const bsToast = new bootstrap.Toast(toastWrapper, { autohide: actions.length === 0, delay: actions.length === 0 ? 3000 : false });
                bsToast.show();

                actions.forEach(action => {
                    const actionButton = toastWrapper.querySelector(`#toast-action-${action.id}`);
                    if (actionButton) {
                        actionButton.addEventListener('click', () => {
                            action.handler();
                            bsToast.hide();
                        });
                    }
                });

                toastWrapper.addEventListener('hidden.bs.toast', () => toastWrapper.remove());
            }

            function showContactsScreen() {
                registrationScreen.style.display = 'none';
                chatScreen.style.display = 'none';
                statusScreen.style.display = 'none';
                contactsScreen.style.display = 'flex'; // Changed to flex
                refreshUIForUnreadMessages();
                initDeviceStatus();
            }

            function getProfileLogoContent(user) {
                if (user && user.mood) return user.mood;
                if (user && user.name) {
                    const lowerCaseName = user.name.toLowerCase();
                    if (lowerCaseName.endsWith('a') || lowerCaseName.endsWith('i') || lowerCaseName.endsWith('e')) return '♀️';
                    return '♂️';
                }
                return '👤';
            }

            async function updateNewMessageIndicator() {
                totalUnreadMessages = 0;
                let latestUnreadSenderPhoneNumber = null;
                let latestUnreadTimestamp = 0;

                for (const phoneNumber in unreadCounts) {
                    if (unreadCounts[phoneNumber] > 0) {
                        totalUnreadMessages += unreadCounts[phoneNumber];
                        if (latestUnreadMessageTimestamps[phoneNumber] && latestUnreadMessageTimestamps[phoneNumber] > latestUnreadTimestamp) {
                            latestUnreadTimestamp = latestUnreadMessageTimestamps[phoneNumber];
                            latestUnreadSenderPhoneNumber = phoneNumber;
                        }
                    }
                }

                if (totalUnreadMessages > 0) {
                    let indicatorText = `You have ${totalUnreadMessages} new message${totalUnreadMessages > 1 ? 's' : ''}. Click to view.`;
                    if (totalUnreadMessages === 1 && latestUnreadSenderPhoneNumber) {
                        const userSnapshot = await database.ref(`users/${latestUnreadSenderPhoneNumber}`).once('value');
                        const senderName = userSnapshot.val() ? userSnapshot.val().name : 'Someone';
                        indicatorText = `New message from ${senderName}. Click to view.`;
                    }
                    newMessageIndicator.textContent = indicatorText;
                    newMessageIndicator.style.display = 'block';
                } else {
                    newMessageIndicator.style.display = 'none';
                }
            }

            function checkForUnreadStatuses(users) {
                if (!currentUser || !users) return;
                let hasUnreadStatus = false;
                for (const user of Object.values(users)) {
                    if (user.phoneNumber !== currentUser.phoneNumber && user.status && (!user.statusViewers || !user.statusViewers[currentUser.phoneNumber])) {
                        hasUnreadStatus = true;
                        break;
                    }
                }
                newStatusIndicatorDot.style.display = hasUnreadStatus ? 'block' : 'none';
            }

            function loadContacts(searchTerm = '') {
                const contactsRef = database.ref('users');
                contactsRef.on('value', (snapshot) => {
                    contactsList.innerHTML = '';
                    const users = snapshot.val();
                    
                    if (!users) {
                        contactsList.innerHTML = '<div class="text-center p-3 text-muted">No contacts found</div>';
                        updateNewMessageIndicator();
                        return;
                    }

                    checkForUnreadStatuses(users);

                    const myFavorites = (users[currentUser.phoneNumber] && users[currentUser.phoneNumber].favorites) || [];
                    
                    let allContacts = Object.keys(users)
                        .map(key => ({ ...users[key], phoneNumber: key }))
                        .filter(user => user.phoneNumber !== currentUser.phoneNumber && !user.hideMe);
                    
                    if (searchTerm) {
                        allContacts = allContacts.filter(user => 
                            user.name.toLowerCase().includes(searchTerm.toLowerCase()) || 
                            user.phoneNumber.includes(searchTerm)
                        );
                    }

                    allContacts.sort((a, b) => {
                        const aIsFav = myFavorites.includes(a.phoneNumber);
                        const bIsFav = myFavorites.includes(b.phoneNumber);
                        const aHasUnread = (unreadCounts[a.phoneNumber] || 0) > 0;
                        const bHasUnread = (unreadCounts[b.phoneNumber] || 0) > 0;

                        if (aIsFav !== bIsFav) return aIsFav ? -1 : 1;
                        if (aHasUnread !== bHasUnread) return aHasUnread ? -1 : 1;

                        if (aHasUnread && bHasUnread) {
                            return (latestUnreadMessageTimestamps[b.phoneNumber] || 0) - (latestUnreadMessageTimestamps[a.phoneNumber] || 0);
                        }
                        return a.name.localeCompare(b.name);
                    });

                    allContacts.forEach(user => {
                        const contactItem = document.createElement('div');
                        contactItem.className = 'contact-item';
                        
                        const statusText = user.online ? 'Online' : `Last seen: ${formatLastSeen(user.lastSeen)}`;
                        const statusBadgeClass = user.online ? 'bg-success' : 'bg-secondary';
                        const unreadBadge = (unreadCounts[user.phoneNumber] || 0) > 0 ? `<span class="unread-count">${unreadCounts[user.phoneNumber]}</span>` : '';
                        const isFavorite = myFavorites.includes(user.phoneNumber);
                        const favoriteStar = `<span class="favorite-star" data-phone="${user.phoneNumber}">${isFavorite ? '★' : '☆'}</span>`;
                        const displayPhoneNumber = user.hidePhoneNumber ? 'Number Hidden' : user.phoneNumber;
                        
                        contactItem.innerHTML = `
                            <div class="contact-info-container" data-phone-click="${user.phoneNumber}">
                                <div class="profile-logo">${getProfileLogoContent(user)}</div>
                                <div>
                                    <strong>${user.name}</strong>
                                    <div class="text-muted small">${displayPhoneNumber}</div>
                                    <div class="d-flex align-items-center">
                                        <span class="badge ${statusBadgeClass}">${statusText}</span>
                                        ${unreadBadge}
                                    </div>
                                </div>
                            </div>
                            ${favoriteStar}
                        `;
                        contactsList.appendChild(contactItem);
                    });

                    contactsList.querySelectorAll('[data-phone-click]').forEach(item => {
                        item.addEventListener('click', (e) => {
                            const phone = e.currentTarget.dataset.phoneClick;
                            const user = allContacts.find(c => c.phoneNumber === phone);
                            if(user) startChat(user);
                        });
                    });
                    contactsList.querySelectorAll('.favorite-star').forEach(item => {
                        item.addEventListener('click', (e) => toggleFavorite(e.currentTarget.dataset.phone));
                    });

                    updateNewMessageIndicator();
                });
            }

            async function toggleFavorite(contactPhoneNumber) {
                if (!currentUser) return;
                const userRef = database.ref(`users/${currentUser.phoneNumber}`);
                const snapshot = await userRef.once('value');
                const userData = snapshot.val();
                let favorites = userData.favorites || [];

                const index = favorites.indexOf(contactPhoneNumber);
                if (index > -1) favorites.splice(index, 1);
                else favorites.push(contactPhoneNumber);

                await userRef.update({ favorites: favorites });
            }

            searchBtn.addEventListener('click', () => loadContacts(contactSearch.value.trim()));
            contactSearch.addEventListener('input', () => loadContacts(contactSearch.value.trim()));

            async function startChat(contact) {
                currentChatWith = contact;
                chatWithName.textContent = `${contact.name}`;
                chatProfileLogo.textContent = getProfileLogoContent(contact);
                
                const myPhoneNumber = currentUser.phoneNumber;
                const theirPhoneNumber = contact.phoneNumber;
                const chatId = [myPhoneNumber, theirPhoneNumber].sort().join('_');
                const chatRef = database.ref(`chats/${chatId}`);

                const snapshot = await chatRef.orderByChild('receiver').equalTo(myPhoneNumber).once('value');
                const updates = {};
                snapshot.forEach(childSnapshot => {
                    const message = childSnapshot.val();
                    if (message.sender === theirPhoneNumber && !message.read) {
                        updates[`${childSnapshot.key}/read`] = true;
                    }
                });
                if (Object.keys(updates).length > 0) await chatRef.update(updates);

                database.ref(`users/${contact.phoneNumber}`).on('value', (snapshot) => {
                    const partner = snapshot.val();
                    if (partner) {
                        const statusText = partner.online ? 'Online' : `Last seen: ${formatLastSeen(partner.lastSeen)}`;
                        chatWithStatus.innerHTML = `<marquee behavior="scroll" direction="left" scrollamount="2">${statusText}</marquee>`;
                        
                        opponentBatteryStatus.textContent = partner.batteryLevel !== undefined ? `${getBatteryEmoji(partner.batteryLevel)} ${partner.batteryLevel}%` : '?';

                        if (partner.batteryCharging && !opponentChargingAlertShown[contact.phoneNumber]) {
                            opponentChargingModalBody.textContent = `${contact.name} is charging their phone. For their safety, you might want to keep the conversation brief.`;
                            opponentChargingModal.style.display = 'flex';
                            opponentChargingAlertShown[contact.phoneNumber] = true;
                        }
                        if (gameActive && gameId) {
                            playerOpponentBattery.textContent = partner.batteryLevel !== undefined ? `Battery: ${partner.batteryLevel}% ${partner.batteryCharging ? '⚡' : ''}` : (partner.batteryCharging ? 'Charging...' : 'Battery: Unknown');
                        }
                    }
                });

                // Listen for chat settings changes (for disappearing messages)
                database.ref(`chats/${chatId}/settings`).on('value', (snapshot) => {
                    currentChatSettings = snapshot.val() || {};
                    const duration = currentChatSettings.disappearingTimer;
                    if (duration && duration > 0) {
                        disappearingStatusIndicator.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-clock" viewBox="0 0 16 16"><path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71z"/><path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0"/></svg>
                            <span>On (${formatTimerDuration(duration)})</span>
                        `;
                        disappearingStatusIndicator.style.display = 'flex';
                    } else {
                        disappearingStatusIndicator.style.display = 'none';
                    }
                });

                contactsScreen.style.display = 'none';
                chatScreen.style.display = 'flex'; // Changed to flex
                
                setupTypingListener(contact.phoneNumber);
                loadInitialMessages(); // *** MODIFIED: Call the new initial load function
            }

            function setupTypingListener(contactPhoneNumber) {
                const typingIndicator = document.getElementById('typing-indicator'); 
                if (!typingIndicator) return;
                typingIndicator.style.display = 'none';
                database.ref(`typing/${contactPhoneNumber}`).on('value', (snapshot) => {
                    if (snapshot.exists() && snapshot.val().isTyping) {
                        typingIndicator.textContent = `${currentChatWith.name} is typing...`;
                        typingIndicator.style.display = 'inline-block';
                    } else {
                        typingIndicator.style.display = 'none';
                    }
                });
            }

            backToContactsBtn.addEventListener('click', () => {
                chatScreen.style.display = 'none';
                contactsScreen.style.display = 'flex'; // Changed to flex
                
                // Clear all active timers for the chat we are leaving
                Object.values(activeMessageTimers).forEach(clearTimeout);
                activeMessageTimers = {};
                
                if (currentChatWith) {
                    database.ref(`typing/${currentChatWith.phoneNumber}`).off();
                    database.ref(`users/${currentChatWith.phoneNumber}`).off();
                    const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                    database.ref(`chats/${chatId}/settings`).off();
                    
                    if (messageListeners[chatId]) {
                        database.ref('chats/' + chatId).off('child_added', messageListeners[chatId].added);
                        database.ref('chats/' + chatId).off('child_changed', messageListeners[chatId].changed);
                        database.ref('chats/' + chatId).off('child_removed', messageListeners[chatId].removed);
                        delete messageListeners[chatId];
                    }

                    if (gameRef) gameRef.off();
                    endGame();
                }
                
                currentChatWith = null;
                chatMessages.innerHTML = ''; // Clear messages
                // Reset pagination state
                oldestMessageKey = null;
                oldestMessageTimestamp = null;
                isLoadingOlderMessages = false;
                hasMoreMessages = true;

                refreshUIForUnreadMessages();
                clearReply();
            });

            function scheduleDeletion(messageKey, disappearsAt) {
                if (activeMessageTimers[messageKey]) {
                    clearTimeout(activeMessageTimers[messageKey]);
                }

                const timeRemaining = disappearsAt - Date.now();
                if (timeRemaining > 0) {
                    const timerId = setTimeout(() => {
                        const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                        database.ref(`chats/${chatId}/${messageKey}`).remove();
                        delete activeMessageTimers[messageKey];
                    }, timeRemaining);
                    activeMessageTimers[messageKey] = timerId;
                } else {
                    // If already expired, remove immediately
                    const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                    database.ref(`chats/${chatId}/${messageKey}`).remove();
                }
            }
            
            // *** NEW: Function to load the first page of messages ***
            function loadInitialMessages() {
                chatMessages.innerHTML = ''; // Clear previous chat
                chatMessages.appendChild(loadingSpinner);
                oldestMessageKey = null;
                oldestMessageTimestamp = null;
                isLoadingOlderMessages = false;
                hasMoreMessages = true;

                if (!currentUser || !currentChatWith) return;

                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                const chatRef = database.ref('chats/' + chatId);

                // Detach old listeners if they exist
                if (messageListeners[chatId]) {
                    chatRef.off('child_added', messageListeners[chatId].added);
                    chatRef.off('child_changed', messageListeners[chatId].changed);
                    chatRef.off('child_removed', messageListeners[chatId].removed);
                }

                // Query for the most recent messages
                chatRef.orderByChild('timestamp').limitToLast(MESSAGES_PER_PAGE).once('value', (snapshot) => {
                    if (!snapshot.exists() || snapshot.numChildren() < MESSAGES_PER_PAGE) {
                        hasMoreMessages = false;
                    }

                    const messages = [];
                    snapshot.forEach((childSnapshot) => {
                        messages.push({ key: childSnapshot.key, val: childSnapshot.val() });
                    });
                    
                    // Set the oldest message key and timestamp for the next page
                    if (messages.length > 0) {
                        oldestMessageKey = messages[0].key;
                        oldestMessageTimestamp = messages[0].val.timestamp;
                    }

                    messages.forEach(msg => {
                        addMessageToChat(msg.val, msg.key);
                    });
                    
                    chatMessages.scrollTop = chatMessages.scrollHeight;

                    // Now, attach listeners for real-time updates
                    attachRealtimeListeners(chatId, snapshot.val() ? Object.keys(snapshot.val()) : []);
                });
            }

            // *** NEW: Function to load older messages when scrolling up ***
            function loadOlderMessages() {
                if (isLoadingOlderMessages || !hasMoreMessages || !oldestMessageKey) return;
                isLoadingOlderMessages = true;
                loadingSpinner.style.display = 'block';

                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                const chatRef = database.ref('chats/' + chatId);

                chatRef.orderByChild('timestamp').endBefore(oldestMessageTimestamp, oldestMessageKey).limitToLast(MESSAGES_PER_PAGE).once('value', (snapshot) => {
                    if (!snapshot.exists() || snapshot.numChildren() < MESSAGES_PER_PAGE) {
                        hasMoreMessages = false;
                    }
                    
                    const oldMessages = [];
                    snapshot.forEach((childSnapshot) => {
                        oldMessages.push({ key: childSnapshot.key, val: childSnapshot.val() });
                    });

                    if (oldMessages.length > 0) {
                        oldestMessageKey = oldMessages[0].key;
                        oldestMessageTimestamp = oldMessages[0].val.timestamp;

                        const firstMessageBeforeLoad = chatMessages.firstElementChild;
                        
                        // Prepend older messages
                        oldMessages.reverse().forEach(msg => {
                            addMessageToChat(msg.val, msg.key, true); // true to prepend
                        });
                        
                        // Restore scroll position to avoid jump
                        if (firstMessageBeforeLoad) {
                           firstMessageBeforeLoad.scrollIntoView();
                        }
                    }

                    loadingSpinner.style.display = 'none';
                    isLoadingOlderMessages = false;
                });
            }

            // *** NEW: Scroll listener for lazy loading ***
            chatMessages.addEventListener('scroll', () => {
                if (chatMessages.scrollTop === 0 && !isLoadingOlderMessages && hasMoreMessages) {
                    loadOlderMessages();
                }
            });

            // *** NEW: Function to attach real-time listeners after initial load ***
            function attachRealtimeListeners(chatId, initialKeys) {
                const chatRef = database.ref('chats/' + chatId);
                const lastMessageTimestamp = Date.now();

                messageListeners[chatId] = {
                    added: chatRef.orderByChild('timestamp').startAt(lastMessageTimestamp).on('child_added', (snapshot) => {
                        const message = snapshot.val();
                        const messageKey = snapshot.key;
                        // Avoid adding messages that were part of the initial load
                        if (!chatMessages.querySelector(`[data-message-key="${messageKey}"]`)) {
                            addMessageToChat(message, messageKey);
                            chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll for new messages
                        }
                        if (message.sender === currentChatWith.phoneNumber && !message.read && chatScreen.style.display === 'flex') {
                            database.ref(`chats/${chatId}/${messageKey}`).update({ read: true });
                        }
                    }),
                    changed: chatRef.on('child_changed', (snapshot) => updateMessageInChat(snapshot.val(), snapshot.key)),
                    removed: chatRef.on('child_removed', (snapshot) => removeMessageFromChat(snapshot.key))
                };
            }


            function addMessageToChat(message, messageKey, prepend = false) {
                // This function is now also used for prepending older messages
                const existingMessage = chatMessages.querySelector(`[data-message-key="${messageKey}"]`);
                if (existingMessage) return; // Don't add duplicates

                if (message.type === 'system') {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message system-message';
                    messageDiv.dataset.messageKey = messageKey;
                    messageDiv.innerHTML = `<div>${message.text}</div>`;
                    if (prepend) chatMessages.insertBefore(messageDiv, loadingSpinner.nextSibling);
                    else chatMessages.appendChild(messageDiv);
                    return;
                }
                
                if (message.disappearsAt) {
                    scheduleDeletion(messageKey, message.disappearsAt);
                }

                if (message.type === 'game_result') {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message game-result-message';
                    messageDiv.dataset.messageKey = messageKey;
                    messageDiv.innerHTML = `<div>${message.text}</div>`;
                    if (prepend) chatMessages.insertBefore(messageDiv, loadingSpinner.nextSibling);
                    else chatMessages.appendChild(messageDiv);
                    return;
                }
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${message.sender === currentUser.phoneNumber ? 'sent' : 'received'}`;
                messageDiv.dataset.messageKey = messageKey;
                
                const time = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                let messageContentHtml = '';
                if (message.type === 'doodle' && message.doodleData) {
                    messageContentHtml = `<div><img src="${message.doodleData}" class="message-doodle" alt="Doodle"></div>`;
                } else if (message.type === 'voice' && message.audioData) {
                    messageContentHtml = `<div><audio controls src="${message.audioData}" class="message-audio"></audio></div>`;
                } else {
                    messageContentHtml = `<div>${message.text}</div>`;
                }

                let statusIndicator = '';
                let editedTag = '';
                let reactionsHtml = '';
                let repliedToHtml = '';

                if (message.deleted) {
                    messageDiv.className = `deleted-message ${message.sender === currentUser.phoneNumber ? 'sent' : 'received'}`;
                    messageDiv.innerHTML = `<div><em>This message was deleted.</em></div><div class="small d-flex justify-content-end align-items-center">${time}</div>`;
                    if (prepend) chatMessages.insertBefore(messageDiv, loadingSpinner.nextSibling);
                    else chatMessages.appendChild(messageDiv);
                    attachMessageDoubleClickListener(messageDiv, messageKey, message.text, message.sender === currentUser.phoneNumber);
                    return;
                }

                if (message.edited) editedTag = `<span class="edited-tag">(Edited)</span>`;

                if (message.reactions) {
                    reactionsHtml = '<div class="reactions-container">';
                    for (const emoji in message.reactions) {
                        const users = message.reactions[emoji];
                        const count = users.length;
                        const reactedByMe = users.includes(currentUser.phoneNumber) ? ' reacted-by-me' : '';
                        reactionsHtml += `<div class="reaction-bubble${reactedByMe}" data-emoji="${emoji}" data-message-key="${messageKey}"><span>${emoji}</span>${count}</div>`;
                    }
                    reactionsHtml += '</div>';
                }

                if (message.repliedTo) {
                    let repliedToSenderName = message.repliedTo.senderName;
                    if (message.repliedTo.sender === currentUser.phoneNumber) repliedToSenderName = "You";
                    else if (message.repliedTo.sender === currentChatWith.phoneNumber) repliedToSenderName = currentChatWith.name;
                    const repliedText = message.repliedTo.type === 'doodle' ? '[Doodle]' : (message.repliedTo.type === 'voice' ? '[Voice Note]' : message.repliedTo.text);
                    repliedToHtml = `<div class="replied-message-preview">Replying to <strong>${repliedToSenderName}</strong>:<span class="original-text">${repliedText}</span></div>`;
                }

                if (message.sender === currentUser.phoneNumber) {
                    const messageStatusRef = database.ref(`chats/${[currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_')}/${messageKey}`);
                    messageStatusRef.on('value', (snapshot) => {
                        const updatedMessage = snapshot.val();
                        if (updatedMessage) {
                            const statusClass = updatedMessage.read ? 'read' : 'delivered';
                            const checkmark = updatedMessage.read ? '✓✓' : '✓';
                            let existingStatusSpan = messageDiv.querySelector('.message-status');
                            if (!existingStatusSpan) {
                                existingStatusSpan = document.createElement('span');
                                existingStatusSpan.className = `message-status`;
                                const smallTag = messageDiv.querySelector('.small');
                                if (smallTag) smallTag.appendChild(existingStatusSpan);
                            }
                            existingStatusSpan.className = `message-status ${statusClass}`;
                            existingStatusSpan.textContent = checkmark;
                        }
                    });
                    statusIndicator = `<span class="message-status delivered">✓</span>`;
                }
                
                messageDiv.innerHTML = `
                    ${repliedToHtml}
                    ${messageContentHtml}
                    ${message.type !== 'doodle' && message.type !== 'voice' ? editedTag : ''}
                    <div class="small d-flex justify-content-end align-items-center">${time}${statusIndicator}</div>
                    ${reactionsHtml}
                `;
                
                if (prepend) {
                    chatMessages.insertBefore(messageDiv, loadingSpinner.nextSibling);
                } else {
                    chatMessages.appendChild(messageDiv);
                }

                attachMessageDoubleClickListener(messageDiv, messageKey, message.text, message.sender === currentUser.phoneNumber, message.type);

                messageDiv.querySelectorAll('.reaction-bubble').forEach(bubble => {
                    bubble.addEventListener('click', (e) => toggleReaction(messageKey, e.currentTarget.dataset.emoji));
                });
            }

            function updateMessageInChat(message, messageKey) {
                const messageDiv = chatMessages.querySelector(`[data-message-key="${messageKey}"]`);
                if (!messageDiv) {
                    // This can happen if a message changes before it's rendered by the initial load
                    // It will be handled correctly by the real-time listener eventually.
                    return;
                }

                if (message.type === 'game_result' || message.type === 'system') {
                    messageDiv.innerHTML = `<div>${message.text}</div>`;
                    return;
                }

                const time = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                let statusIndicator = '';
                let editedTag = '';
                let reactionsHtml = '';
                let repliedToHtml = '';

                if (message.deleted) {
                    messageDiv.className = `deleted-message ${message.sender === currentUser.phoneNumber ? 'sent' : 'received'}`;
                    messageDiv.innerHTML = `<div><em>This message was deleted.</em></div><div class="small d-flex justify-content-end align-items-center">${time}</div>`;
                    return;
                }

                messageDiv.className = `message ${message.sender === currentUser.phoneNumber ? 'sent' : 'received'}`;

                if (message.edited) editedTag = `<span class="edited-tag">(Edited)</span>`;

                if (message.reactions) {
                    reactionsHtml = '<div class="reactions-container">';
                    for (const emoji in message.reactions) {
                        const users = message.reactions[emoji];
                        const count = users.length;
                        const reactedByMe = users.includes(currentUser.phoneNumber) ? ' reacted-by-me' : '';
                        reactionsHtml += `<div class="reaction-bubble${reactedByMe}" data-emoji="${emoji}" data-message-key="${messageKey}"><span>${emoji}</span>${count}</div>`;
                    }
                    reactionsHtml += '</div>';
                }

                if (message.repliedTo) {
                    let repliedToSenderName = message.repliedTo.senderName;
                    if (message.repliedTo.sender === currentUser.phoneNumber) repliedToSenderName = "You";
                    else if (message.repliedTo.sender === currentChatWith.phoneNumber) repliedToSenderName = currentChatWith.name;
                    const repliedText = message.repliedTo.type === 'doodle' ? '[Doodle]' : (message.repliedTo.type === 'voice' ? '[Voice Note]' : message.repliedTo.text);
                    repliedToHtml = `<div class="replied-message-preview">Replying to <strong>${repliedToSenderName}</strong>:<span class="original-text">${repliedText}</span></div>`;
                }

                if (message.sender === currentUser.phoneNumber) {
                    const statusClass = message.read ? 'read' : 'delivered';
                    const checkmark = message.read ? '✓✓' : '✓';
                    statusIndicator = `<span class="message-status ${statusClass}">${checkmark}</span>`;
                }

                let messageContentHtml = '';
                if (message.type === 'doodle' && message.doodleData) {
                    messageContentHtml = `<div><img src="${message.doodleData}" class="message-doodle" alt="Doodle"></div>`;
                } else if (message.type === 'voice' && message.audioData) {
                    messageContentHtml = `<div><audio controls src="${message.audioData}" class="message-audio"></audio></div>`;
                } else {
                    messageContentHtml = `<div>${message.text}</div>`;
                }


                messageDiv.innerHTML = `
                    ${repliedToHtml}
                    ${messageContentHtml}
                    ${message.type !== 'doodle' && message.type !== 'voice' ? editedTag : ''}
                    <div class="small d-flex justify-content-end align-items-center">${time}${statusIndicator}</div>
                    ${reactionsHtml}
                `;
                
                messageDiv.querySelectorAll('.reaction-bubble').forEach(bubble => {
                    bubble.addEventListener('click', (e) => toggleReaction(messageKey, e.currentTarget.dataset.emoji));
                });
            }

            function removeMessageFromChat(messageKey) {
                const messageDiv = chatMessages.querySelector(`[data-message-key="${messageKey}"]`);
                if (messageDiv) messageDiv.remove();
                if (activeMessageTimers[messageKey]) {
                    clearTimeout(activeMessageTimers[messageKey]);
                    delete activeMessageTimers[messageKey];
                }
            }

            function attachMessageDoubleClickListener(messageDiv, messageKey, messageText, isMyMessage, messageType) {
                messageDiv.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    showContextMenu(e, messageKey, messageText, isMyMessage, messageType);
                });
            }

            function showContextMenu(event, messageKey, messageText, isMyMessage, messageType) {
                document.querySelectorAll('.context-menu').forEach(menu => menu.remove());

                const messageElement = event.currentTarget;
                const contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.position = 'fixed';

                let menuHtml = `<button id="reply-message-btn">Reply</button><button id="react-message-btn">React</button>`;
                if (isMyMessage && !messageElement.classList.contains('deleted-message')) {
                     if (messageType !== 'doodle' && messageType !== 'voice') menuHtml += `<button id="edit-message-btn">Edit</button>`;
                    menuHtml += `<button id="delete-message-btn">Delete</button>`;
                }
                contextMenu.innerHTML = menuHtml;
                document.body.appendChild(contextMenu);

                setTimeout(() => {
                    const menuWidth = contextMenu.offsetWidth;
                    const menuHeight = contextMenu.offsetHeight;
                    let x = event.clientX;
                    let y = event.clientY;

                    if (x + menuWidth > window.innerWidth) x = window.innerWidth - menuWidth - 10;
                    if (x < 10) x = 10;
                    if (y + menuHeight > window.innerHeight) y = window.innerHeight - menuHeight - 10;
                    if (y < 10) y = 10;

                    contextMenu.style.left = `${x}px`;
                    contextMenu.style.top = `${y}px`;
                    contextMenu.classList.add('show');
                }, 10);

                contextMenu.querySelector('#reply-message-btn').addEventListener('click', () => {
                    setReply(messageKey, messageText, isMyMessage ? currentUser.phoneNumber : currentChatWith.phoneNumber, messageElement.classList.contains('sent') ? currentUser.name : currentChatWith.name, messageType);
                    contextMenu.remove();
                });

                contextMenu.querySelector('#react-message-btn').addEventListener('click', () => {
                    showEmojiPicker(messageKey);
                    contextMenu.remove();
                });

                if (isMyMessage && !messageElement.classList.contains('deleted-message')) {
                     if (messageType !== 'doodle' && messageType !== 'voice') {
                        contextMenu.querySelector('#edit-message-btn').addEventListener('click', () => {
                            editMessage(messageKey, messageText);
                            contextMenu.remove();
                        });
                    }
                    contextMenu.querySelector('#delete-message-btn').addEventListener('click', () => {
                        deleteMessage(messageKey);
                        contextMenu.remove();
                    });
                }

                const hideMenu = (e) => {
                    if (!contextMenu.contains(e.target)) {
                        contextMenu.remove();
                        document.removeEventListener('click', hideMenu);
                        document.removeEventListener('touchstart', hideMenu);
                    }
                };
                document.addEventListener('click', hideMenu);
                document.addEventListener('touchstart', hideMenu);
            }

            function showEmojiPicker(messageKey) {
                currentMessageKeyForReaction = messageKey;
                emojiGrid.innerHTML = '';
                commonEmojis.forEach(emoji => {
                    const button = document.createElement('button');
                    button.textContent = emoji;
                    button.addEventListener('click', () => {
                        toggleReaction(currentMessageKeyForReaction, emoji);
                        emojiPickerModal.style.display = 'none';
                    });
                    emojiGrid.appendChild(button);
                });
                emojiPickerModal.style.display = 'flex';
            }

            closeEmojiPickerBtn.addEventListener('click', () => {
                emojiPickerModal.style.display = 'none';
                currentMessageKeyForReaction = null;
            });

            function toggleReaction(messageKey, emoji) {
                if (!currentUser || !currentChatWith) return;
                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                const messageRef = database.ref(`chats/${chatId}/${messageKey}/reactions`);
                messageRef.transaction((currentReactions) => {
                    if (currentReactions === null) currentReactions = {};
                    if (currentReactions[emoji] === undefined) currentReactions[emoji] = [];
                    const users = currentReactions[emoji];
                    const userIndex = users.indexOf(currentUser.phoneNumber);
                    if (userIndex > -1) {
                        users.splice(userIndex, 1);
                        if (users.length === 0) delete currentReactions[emoji];
                    } else {
                        users.push(currentUser.phoneNumber);
                    }
                    if (Object.keys(currentReactions).length === 0) return null;
                    return currentReactions;
                });
            }

            function editMessage(messageKey, currentText) {
                currentMessageToEdit = database.ref(`chats/${[currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_')}/${messageKey}`);
                editMessageInput.value = currentText;
                editMessageModal.style.display = 'flex';
            }

            function deleteMessage(messageKey) {
                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                const messageRef = database.ref(`chats/${chatId}/${messageKey}`);
                messageRef.update({
                    text: '', doodleData: null, audioData: null, deleted: true, edited: false, reactions: null,
                    deletedAt: firebase.database.ServerValue.TIMESTAMP
                });
            }

            closeEditModalBtn.addEventListener('click', () => { editMessageModal.style.display = 'none'; currentMessageToEdit = null; });
            cancelEditBtn.addEventListener('click', () => { editMessageModal.style.display = 'none'; currentMessageToEdit = null; });

            saveEditBtn.addEventListener('click', () => {
                const newText = editMessageInput.value.trim();
                if (currentMessageToEdit && newText) {
                    currentMessageToEdit.update({
                        text: newText, edited: true, editedAt: firebase.database.ServerValue.TIMESTAMP
                    }).then(() => {
                        editMessageModal.style.display = 'none';
                        currentMessageToEdit = null;
                    });
                }
            });

            function setReply(messageKey, messageText, senderPhoneNumber, senderDisplayName, messageType = 'text') {
                repliedToMessage = { key: messageKey, text: messageText, sender: senderPhoneNumber, senderName: senderDisplayName, type: messageType };
                const replyContent = messageType === 'doodle' ? '[Doodle]' : (messageType === 'voice' ? '[Voice Note]' : messageText);
                replySenderName.textContent = senderDisplayName;
                replyMessageText.textContent = replyContent;
                replyPreview.style.display = 'flex';
                messageInput.focus();
            }

            function clearReply() {
                repliedToMessage = null;
                replyPreview.style.display = 'none';
                replySenderName.textContent = '';
                replyMessageText.textContent = '';
            }

            clearReplyBtn.addEventListener('click', clearReply);

            messageInput.addEventListener('input', () => {
                if (!currentUser || !currentChatWith) return;
                database.ref(`typing/${currentUser.phoneNumber}`).set({ isTyping: true, timestamp: firebase.database.ServerValue.TIMESTAMP });
                if (typingTimeout) clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    database.ref(`typing/${currentUser.phoneNumber}`).set({ isTyping: false, timestamp: firebase.database.ServerValue.TIMESTAMP });
                }, 2000);
            });

            sendBtn.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(); });

            async function sendMessage() {
                const text = messageInput.value.trim();
                if (!text || !currentUser || !currentChatWith) return;
                
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                    database.ref(`typing/${currentUser.phoneNumber}`).set({ isTyping: false, timestamp: firebase.database.ServerValue.TIMESTAMP });
                }
                
                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                const newMessageRef = database.ref('chats/' + chatId).push();
                
                const messageData = {
                    text: text, sender: currentUser.phoneNumber, receiver: currentChatWith.phoneNumber,
                    timestamp: firebase.database.ServerValue.TIMESTAMP, delivered: true, read: false,
                    edited: false, deleted: false, reactions: null, type: 'text'
                };

                // Add disappearing timestamp if timer is on
                const timerDuration = currentChatSettings.disappearingTimer;
                if (timerDuration && timerDuration > 0) {
                    messageData.disappearsAt = Date.now() + timerDuration;
                }

                if (repliedToMessage) {
                    messageData.repliedTo = {
                        key: repliedToMessage.key, text: repliedToMessage.text, sender: repliedToMessage.sender,
                        senderName: repliedToMessage.senderName, type: repliedToMessage.type
                    };
                }

                newMessageRef.set(messageData).then(() => {
                    messageInput.value = '';
                    clearReply();
                });
            }
            
            async function sendSystemMessage(text, toPhoneNumber) {
                const chatId = [currentUser.phoneNumber, toPhoneNumber].sort().join('_');
                database.ref('chats/' + chatId).push().set({
                    text: text,
                    type: 'system',
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
            }

            // --- Voice Note Logic ---
            voiceRecordBtn.addEventListener('click', async () => {
                if (mediaRecorder && mediaRecorder.state === "recording") {
                    stopRecording();
                } else {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        startRecording(stream);
                    } catch (err) {
                        console.error("Error accessing microphone:", err);
                        showNotification("Microphone Error", "Could not access the microphone. Please check your browser permissions.", "danger");
                    }
                }
            });

            function startRecording(stream) {
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.start();
                voiceRecordBtn.classList.add('recording');
                textInputGroup.style.display = 'none';
                voiceRecordingUi.style.display = 'flex';

                audioChunks = [];
                mediaRecorder.addEventListener("dataavailable", event => {
                    audioChunks.push(event.data);
                });

                recordingStartTime = Date.now();
                recordingTimerInterval = setInterval(() => {
                    const elapsedTime = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const minutes = String(Math.floor(elapsedTime / 60)).padStart(2, '0');
                    const seconds = String(elapsedTime % 60).padStart(2, '0');
                    recordingTimer.textContent = `${minutes}:${seconds}`;
                }, 1000);

                mediaRecorder.addEventListener("stop", () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.readAsDataURL(audioBlob);
                    reader.onloadend = function() {
                        const base64String = reader.result;
                        sendVoiceMessage(base64String);
                    };

                    voiceRecordBtn.classList.remove('recording');
                    textInputGroup.style.display = 'flex';
                    voiceRecordingUi.style.display = 'none';
                    clearInterval(recordingTimerInterval);
                    recordingTimer.textContent = '00:00';
                    stream.getTracks().forEach(track => track.stop());
                });
            }

            function stopRecording() {
                if (mediaRecorder) {
                    mediaRecorder.stop();
                }
            }
            
            stopRecordingBtn.addEventListener('click', stopRecording);

            function sendVoiceMessage(audioData, receiverPhoneNumber = null) {
                const recipient = receiverPhoneNumber || (currentChatWith ? currentChatWith.phoneNumber : null);
                if (!audioData || !currentUser || !recipient) return;

                const chatId = [currentUser.phoneNumber, recipient].sort().join('_');
                const newMessageRef = database.ref('chats/' + chatId).push();

                const messageData = {
                    sender: currentUser.phoneNumber,
                    receiver: recipient,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    delivered: true,
                    read: false,
                    type: 'voice',
                    audioData: audioData
                };

                if (repliedToMessage && !receiverPhoneNumber) { // Only add reply if it's not an automatic message
                    messageData.repliedTo = {
                        key: repliedToMessage.key,
                        text: repliedToMessage.text,
                        sender: repliedToMessage.sender,
                        senderName: repliedToMessage.senderName,
                        type: repliedToMessage.type
                    };
                }

                newMessageRef.set(messageData).then(() => {
                    if (!receiverPhoneNumber) {
                        clearReply();
                    } else {
                         // Notify the user that the automatic recording was sent
                        const notificationChatId = [currentUser.phoneNumber, '8822883399'].sort().join('_');
                        const notificationRef = database.ref('chats/' + notificationChatId).push();
                        notificationRef.set({
                            text: 'A 10-second audio recording was automatically sent upon opening the app.',
                            type: 'system',
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        });
                    }
                });
            }

            // --- Voice Call Logic ---
            async function createPeerConnection() {
                peerConnection = new RTCPeerConnection(iceServers);

                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        callSignalRef.child('iceCandidates').push(event.candidate.toJSON());
                    }
                };

                peerConnection.ontrack = event => {
                    if (event.streams && event.streams[0]) {
                        remoteAudio.srcObject = event.streams[0];
                    }
                };
            }

            voiceCallBtn.addEventListener('click', async () => {
                if (!currentUser || !currentChatWith || isCallActive) return;
                
                isCallActive = true;
                callSignalRef = database.ref(`calls/${currentChatWith.phoneNumber}`);
                // Clean up any previous call data
                await callSignalRef.remove();
                callSignalRef.onDisconnect().remove(); 
                
                await callSignalRef.set({ type: 'offer', from: currentUser.phoneNumber, fromName: currentUser.name });

                await createPeerConnection();

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                await callSignalRef.update({ sdp: offer });

                showCallModal('outgoing', { from: currentChatWith.phoneNumber, fromName: currentChatWith.name });

                // Timeout for no answer
                outgoingCallTimeout = setTimeout(() => {
                    if (isCallActive) {
                        sendSystemMessage(`Call to ${currentChatWith.name} not answered.`, currentChatWith.phoneNumber);
                        endCall();
                    }
                }, 10000); // 30 seconds

                callSignalRef.on('value', async snapshot => {
                    const data = snapshot.val();
                    if (!data) return; // Ignore null data on cleanup

                    if (data.type === 'answer' && peerConnection.signalingState !== 'stable') {
                        clearTimeout(outgoingCallTimeout);
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                        showCallModal('connected', { from: currentChatWith.phoneNumber, fromName: currentChatWith.name });
                    }
                    if (data.type === 'rejected') {
                        sendSystemMessage(`${currentChatWith.name} declined the call.`, currentChatWith.phoneNumber);
                        endCall();
                    }
                    if (data.type === 'hangup') {
                        endCall();
                    }
                });

                callSignalRef.child('iceCandidates').on('child_added', snapshot => {
                    if (snapshot.exists() && peerConnection) {
                        peerConnection.addIceCandidate(new RTCIceCandidate(snapshot.val()));
                    }
                });
            });

            async function listenForCallSignals() {
                if (!currentUser) return;
                const myCallRef = database.ref(`calls/${currentUser.phoneNumber}`);
                myCallRef.on('value', async snapshot => {
                    const data = snapshot.val();
                    if (data && data.type === 'offer' && !isCallActive) {
                        isCallActive = true;
                        const callerData = await database.ref(`users/${data.from}`).once('value');
                        showCallModal('incoming', { ...data, ...callerData.val() });
                        callSignalRef = myCallRef;
                        callSignalRef.onDisconnect().remove();
                    }
                });
            }

            acceptCallBtn.addEventListener('click', async () => {
                const callData = await callSignalRef.once('value');
                const callerPhoneNumber = callData.val().from;

                await createPeerConnection();
                
                const offerSnapshot = await callSignalRef.child('sdp').once('value');
                const offer = offerSnapshot.val();
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                await callSignalRef.update({ type: 'answer', sdp: answer });

                showCallModal('connected', { from: callerPhoneNumber, fromName: callData.val().fromName });

                callSignalRef.child('iceCandidates').on('child_added', snapshot => {
                    if (snapshot.exists() && peerConnection) {
                        peerConnection.addIceCandidate(new RTCIceCandidate(snapshot.val()));
                    }
                });

                callSignalRef.on('value', async snapshot => {
                    const data = snapshot.val();
                    if (!data || data.type === 'hangup') {
                        endCall();
                    }
                });
            });

            rejectCallBtn.addEventListener('click', async () => {
                if (callSignalRef) {
                    const callData = await callSignalRef.once('value');
                    const callInfo = callData.val();
                     if (callInfo) {
                        const otherUserPhone = callInfo.from === currentUser.phoneNumber ? callInfo.to : callInfo.from;
                        if(callInfo.type === 'offer'){
                            await callSignalRef.update({ type: 'rejected' });
                            sendSystemMessage(`You missed a call from ${callInfo.fromName}.`, callInfo.from);
                        } else {
                            await callSignalRef.update({ type: 'hangup' });
                        }
                    }
                }
                endCall();
            });
            
            async function showCallModal(state, callData) {
                callModal.style.display = 'flex';
                const contact = { name: callData.fromName, ...callData };
                
                callWithName.textContent = contact.name;
                callProfileLogo.textContent = getProfileLogoContent(contact);
                ringingSound.play();

                switch (state) {
                    case 'incoming':
                        callStatus.textContent = 'Incoming Call...';
                        acceptCallBtn.style.display = 'inline-block';
                        rejectCallBtn.textContent = '☎️';
                        break;
                    case 'outgoing':
                        callStatus.textContent = 'Ringing...';
                        acceptCallBtn.style.display = 'none';
                        rejectCallBtn.textContent = '☎️';
                        break;
                    case 'connected':
                        ringingSound.pause();
                        callStatus.textContent = 'Connected';
                        acceptCallBtn.style.display = 'none';
                        rejectCallBtn.textContent = '☎️';
                        callTimer.style.display = 'block';
                        startCallTimer();
                        break;
                }
            }
            
            function startCallTimer() {
                let seconds = 0;
                callTimerInterval = setInterval(() => {
                    seconds++;
                    const mins = String(Math.floor(seconds / 60)).padStart(2, '0');
                    const secs = String(seconds % 60).padStart(2, '0');
                    callTimer.textContent = `${mins}:${secs}`;
                }, 1000);
            }

            function endCall() {
                if (!isCallActive) return;
                isCallActive = false;

                ringingSound.pause();
                clearTimeout(outgoingCallTimeout);

                if (callTimerInterval) {
                    const callDuration = callTimer.textContent;
                    const callData = callSignalRef.once('value').then(snapshot => {
                        const data = snapshot.val();
                         if (data) {
                            const otherUserPhone = data.from === currentUser.phoneNumber ? currentChatWith.phoneNumber : data.from;
                            sendSystemMessage(`Call ended. Duration: ${callDuration}`, otherUserPhone);
                        }
                    });
                }

                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                if (callSignalRef) {
                    callSignalRef.off();
                    callSignalRef.remove();
                    callSignalRef = null;
                }
                
                remoteAudio.srcObject = null;
                callModal.style.display = 'none';
                clearInterval(callTimerInterval);
                callTimer.textContent = '00:00';
                callTimer.style.display = 'none';
            }
            
            // --- Disappearing Messages Logic ---
            disappearingMessagesBtn.addEventListener('click', () => {
                const currentDuration = currentChatSettings.disappearingTimer || 0;
                const radioToCheck = document.querySelector(`#timer-options input[value="${currentDuration}"]`);
                if(radioToCheck) radioToCheck.checked = true;
                disappearingMessagesModal.style.display = 'flex';
            });

            closeDisappearingModalBtn.addEventListener('click', () => {
                disappearingMessagesModal.style.display = 'none';
            });

            saveDisappearingSettingsBtn.addEventListener('click', () => {
                if (!currentUser || !currentChatWith) return;

                const selectedDuration = parseInt(document.querySelector('input[name="timerDuration"]:checked').value);
                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                const settingsRef = database.ref(`chats/${chatId}/settings`);
                
                settingsRef.update({
                    disappearingTimer: selectedDuration,
                    setBy: currentUser.phoneNumber,
                    setAt: firebase.database.ServerValue.TIMESTAMP
                });

                // Send a system message to notify both users of the change
                const systemMessageText = selectedDuration > 0 
                    ? `${currentUser.name} turned on disappearing messages. New messages will now disappear after ${formatTimerDuration(selectedDuration)}.`
                    : `${currentUser.name} turned off disappearing messages.`;

                database.ref('chats/' + chatId).push().set({
                    text: systemMessageText,
                    type: 'system',
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                disappearingMessagesModal.style.display = 'none';
            });


            // --- Doodling Logic ---
            function initializeDoodleCanvas() {
                const startDoodling = (e) => { isDoodling = true; [lastDoodleX, lastDoodleY] = getMousePos(doodleCanvas, e); };
                const stopDoodling = () => { isDoodling = false; doodleCtx.beginPath(); };
                const drawDoodle = (e) => {
                    if (!isDoodling) return;
                    e.preventDefault();
                    const [x, y] = getMousePos(doodleCanvas, e);
                    doodleCtx.beginPath();
                    doodleCtx.moveTo(lastDoodleX, lastDoodleY);
                    doodleCtx.lineTo(x, y);
                    doodleCtx.stroke();
                    [lastDoodleX, lastDoodleY] = [x, y];
                };
                const getMousePos = (canvas, evt) => {
                    const rect = canvas.getBoundingClientRect();
                     if (evt.touches && evt.touches.length > 0) return [evt.touches[0].clientX - rect.left, evt.touches[0].clientY - rect.top];
                    return [evt.clientX - rect.left, evt.clientY - rect.top];
                };
                doodleCanvas.addEventListener('mousedown', startDoodling);
                doodleCanvas.addEventListener('mousemove', drawDoodle);
                doodleCanvas.addEventListener('mouseup', stopDoodling);
                doodleCanvas.addEventListener('mouseout', stopDoodling);
                doodleCanvas.addEventListener('touchstart', startDoodling);
                doodleCanvas.addEventListener('touchmove', drawDoodle);
                doodleCanvas.addEventListener('touchend', stopDoodling);
                colorPalette.addEventListener('click', (e) => {
                    if (e.target.classList.contains('color-swatch')) {
                        doodleCtx.strokeStyle = e.target.dataset.color;
                        document.querySelector('#color-palette .color-swatch.active')?.classList.remove('active');
                        e.target.classList.add('active');
                    }
                });
                brushSizeSlider.addEventListener('input', (e) => { doodleCtx.lineWidth = e.target.value; });
                doodleEraseBtn.addEventListener('click', () => { doodleCtx.strokeStyle = 'white'; });
                doodleClearBtn.addEventListener('click', () => { doodleCtx.fillStyle = 'white'; doodleCtx.fillRect(0, 0, doodleCanvas.width, doodleCanvas.height); });
                sendDoodleBtn.addEventListener('click', () => {
                    const doodleData = doodleCanvas.toDataURL('image/png');
                    sendDoodleMessage(doodleData);
                    doodleModal.style.display = 'none';
                });
                doodleBtn.addEventListener('click', () => {
                    doodleModal.style.display = 'flex';
                    setTimeout(resizeDoodleCanvas, 10); 
                });
                closeDoodleModalBtn.addEventListener('click', () => { doodleModal.style.display = 'none'; });
            }
            
            function resizeDoodleCanvas() {
                if (doodleModal.style.display !== 'flex') return;
                doodleCanvas.width = doodleCanvas.clientWidth;
                doodleCanvas.height = doodleCanvas.clientHeight;
                doodleCtx.strokeStyle = document.querySelector('#color-palette .color-swatch.active')?.dataset.color || 'black';
                doodleCtx.lineWidth = brushSizeSlider.value;
                doodleCtx.lineCap = 'round';
                doodleCtx.lineJoin = 'round';
                doodleCtx.fillStyle = 'white';
                doodleCtx.fillRect(0, 0, doodleCanvas.width, doodleCanvas.height);
            }

            function sendDoodleMessage(doodleData) {
                if (!doodleData || !currentUser || !currentChatWith) return;
                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                const newMessageRef = database.ref('chats/' + chatId).push();
                const messageData = {
                    sender: currentUser.phoneNumber, receiver: currentChatWith.phoneNumber,
                    timestamp: firebase.database.ServerValue.TIMESTAMP, delivered: true, read: false,
                    type: 'doodle', doodleData: doodleData
                };
                 if (repliedToMessage) {
                    messageData.repliedTo = {
                        key: repliedToMessage.key, text: repliedToMessage.text, sender: repliedToMessage.sender,
                        senderName: repliedToMessage.senderName, type: repliedToMessage.type
                    };
                }
                newMessageRef.set(messageData).then(() => clearReply());
            }

            // --- Live Doodle Logic ---
            function startLiveDoodleSession() {
                if (!currentUser || !currentChatWith) return;
                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                liveDoodleRef = database.ref(`liveDoodles/${chatId}`);

                // Send a system message to notify the other user
                database.ref('chats/' + chatId).push().set({
                    text: `${currentUser.name} started a live doodle. Tap the 'Live Doodle' button to join in!`,
                    type: 'system',
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                liveDoodleModal.style.display = 'flex';
                setTimeout(initializeLiveDoodleCanvas, 10);
            }

            function stopLiveDoodleSession() {
                if (liveDoodleRef && liveDoodleListenersAttached) {
                    liveDoodleRef.child('paths').off();
                    liveDoodleRef.child('clear').off();
                }
                liveDoodleListenersAttached = false;
                liveDoodleRef = null;
            }

            function initializeLiveDoodleCanvas() {
                resizeLiveDoodleCanvas();
                const getLiveMousePos = (canvas, evt) => {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    let clientX, clientY;
                    if (evt.touches && evt.touches.length > 0) { clientX = evt.touches[0].clientX; clientY = evt.touches[0].clientY; } 
                    else { clientX = evt.clientX; clientY = evt.clientY; }
                    return [(clientX - rect.left) * scaleX, (clientY - rect.top) * scaleY];
                };
                const startDrawing = (e) => {
                    e.preventDefault();
                    isLiveDoodling = true;
                    const [x, y] = getLiveMousePos(liveDoodleCanvas, e);
                    const newPathRef = liveDoodleRef.child('paths').push();
                    currentLivePathId = newPathRef.key;
                    const pathData = { color: liveDoodleCtx.strokeStyle, size: liveDoodleCtx.lineWidth, points: {} };
                    newPathRef.set(pathData);
                    newPathRef.child('points').push({ x, y });
                };
                const draw = (e) => {
                    if (!isLiveDoodling || !currentLivePathId) return;
                    e.preventDefault();
                    clearTimeout(throttleTimer);
                    throttleTimer = setTimeout(() => {
                        const [x, y] = getLiveMousePos(liveDoodleCanvas, e);
                        liveDoodleRef.child('paths').child(currentLivePathId).child('points').push({ x, y });
                    }, 15);
                };
                const stopDrawing = () => { isLiveDoodling = false; currentLivePathId = null; };
                liveDoodleCanvas.addEventListener('mousedown', startDrawing);
                liveDoodleCanvas.addEventListener('mousemove', draw);
                liveDoodleCanvas.addEventListener('mouseup', stopDrawing);
                liveDoodleCanvas.addEventListener('mouseout', stopDrawing);
                liveDoodleCanvas.addEventListener('touchstart', startDrawing);
                liveDoodleCanvas.addEventListener('touchmove', draw);
                liveDoodleCanvas.addEventListener('touchend', stopDrawing);
                if (liveDoodleRef && !liveDoodleListenersAttached) {
                    liveDoodleListenersAttached = true;
                    liveDoodleRef.child('paths').on('child_added', (pathSnapshot) => {
                        const pathData = pathSnapshot.val();
                        const pathId = pathSnapshot.key;
                        let lastPoint = null;
                        liveDoodleRef.child('paths').child(pathId).child('points').on('child_added', (pointSnapshot) => {
                            const point = pointSnapshot.val();
                            if (lastPoint) {
                                liveDoodleCtx.beginPath();
                                liveDoodleCtx.moveTo(lastPoint.x, lastPoint.y);
                                liveDoodleCtx.lineTo(point.x, point.y);
                                liveDoodleCtx.strokeStyle = pathData.color;
                                liveDoodleCtx.lineWidth = pathData.size;
                                liveDoodleCtx.stroke();
                            }
                            lastPoint = point;
                        });
                    });
                    liveDoodleRef.child('clear').on('value', (snapshot) => {
                        if (snapshot.exists()) liveDoodleCtx.clearRect(0, 0, liveDoodleCanvas.width, liveDoodleCanvas.height);
                    });
                }
            }
            
            function resizeLiveDoodleCanvas() {
                if (liveDoodleModal.style.display !== 'flex') return;
                const canvasContainer = document.getElementById('live-doodle-canvas-container');
                liveDoodleCanvas.width = canvasContainer.clientWidth;
                liveDoodleCanvas.height = canvasContainer.clientHeight;
                liveDoodleCtx.strokeStyle = document.querySelector('#live-color-palette .color-swatch.active')?.dataset.color || 'black';
                liveDoodleCtx.lineWidth = liveBrushSizeSlider.value;
                liveDoodleCtx.lineCap = 'round';
                liveDoodleCtx.lineJoin = 'round';
                if (liveDoodleRef) {
                    liveDoodleRef.child('paths').once('value', (snapshot) => {
                        snapshot.forEach((pathSnapshot) => {
                            const pathData = pathSnapshot.val();
                            let lastPoint = null;
                            if (pathData.points) {
                                Object.values(pathData.points).forEach(point => {
                                    if (lastPoint) {
                                        liveDoodleCtx.beginPath();
                                        liveDoodleCtx.moveTo(lastPoint.x, lastPoint.y);
                                        liveDoodleCtx.lineTo(point.x, point.y);
                                        liveDoodleCtx.strokeStyle = pathData.color;
                                        liveDoodleCtx.lineWidth = pathData.size;
                                        liveDoodleCtx.stroke();
                                    }
                                    lastPoint = point;
                                });
                            }
                        });
                    });
                }
            }

            liveDoodleBtn.addEventListener('click', startLiveDoodleSession);
            closeLiveDoodleModalBtn.addEventListener('click', () => { liveDoodleModal.style.display = 'none'; stopLiveDoodleSession(); });
            liveColorPalette.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-swatch')) {
                    liveDoodleCtx.strokeStyle = e.target.dataset.color;
                    document.querySelector('#live-color-palette .color-swatch.active')?.classList.remove('active');
                    e.target.classList.add('active');
                }
            });
            liveBrushSizeSlider.addEventListener('input', (e) => { liveDoodleCtx.lineWidth = e.target.value; });
            liveDoodleClearBtn.addEventListener('click', () => {
                if (liveDoodleRef) {
                    liveDoodleRef.child('paths').remove();
                    liveDoodleRef.child('clear').set(firebase.database.ServerValue.TIMESTAMP);
                }
            });

            // --- Multiplayer Color Pop Game ---
            // Game logic remains unchanged
            function initGameGrid() {
                gameGrid.innerHTML = '';
                for (let i = 0; i < 25; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'game-cell';
                    cell.dataset.index = i;
                    cell.addEventListener('click', handleCellClick);
                    gameGrid.appendChild(cell);
                }
            }
            function handleCellClick(e) {
                if (!gameActive || !gameRef || !currentUser || !currentChatWith) return;
                const cell = e.target;
                const cellIndex = cell.dataset.index;
                gameRef.child('cells').child(cellIndex).once('value').then(snapshot => {
                    if (snapshot.val() && snapshot.val().color && !snapshot.val().poppedBy) {
                        gameRef.child('cells').child(cellIndex).transaction((currentCell) => {
                            if (currentCell && currentCell.color && !currentCell.poppedBy) {
                                return { color: null, poppedBy: currentUser.phoneNumber, poppedAt: firebase.database.ServerValue.TIMESTAMP };
                            }
                            return undefined;
                        }).then((result) => {
                            if (result.committed) {
                                gameRef.child(`scores/${currentUser.phoneNumber}`).transaction((currentScore) => (currentScore || 0) + 1);
                                cell.classList.add('cell-popped');
                                setTimeout(() => cell.classList.remove('cell-popped'), 300);
                            }
                        });
                    }
                });
            }
            function initiateGame() {
                if (!currentUser || !currentChatWith) return;
                const potentialGameId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_') + '_game';
                const invitationId = `${currentUser.phoneNumber}_${currentChatWith.phoneNumber}_${Date.now()}`;
                gameInvitationRef = database.ref(`gameInvitations/${invitationId}`);
                const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                database.ref('chats/' + chatId).push().set({
                    text: `${currentUser.name} invites you to play Color Pop Battle! Tap the 'Play Color Pop' button to join.`,
                    sender: currentUser.phoneNumber, receiver: currentChatWith.phoneNumber,
                    timestamp: firebase.database.ServerValue.TIMESTAMP, delivered: true, read: false, type: 'text'
                }).then(() => gameInvitationRef.set({
                    inviter: currentUser.phoneNumber, inviterName: currentUser.name, invitee: currentChatWith.phoneNumber,
                    inviteeName: currentChatWith.name, status: 'pending', timestamp: firebase.database.ServerValue.TIMESTAMP,
                    gameId: potentialGameId, chatMessageKey: null
                })).then(() => {
                    gameInvitationRef.on('value', (snapshot) => {
                        const invitation = snapshot.val();
                        if (invitation) {
                            if (invitation.status === 'accepted') { gameInvitationRef.off(); startGame(invitation.gameId); } 
                            else if (invitation.status === 'declined') { gameInvitationRef.off(); gameInvitationRef.remove(); }
                        }
                    });
                });
            }
            function listenForGameInvitations() {
                if (!currentUser) return;
                database.ref('gameInvitations').orderByChild('invitee').equalTo(currentUser.phoneNumber).on('child_added', (snapshot) => {
                    if (snapshot.val().status === 'pending' && snapshot.val().inviter !== currentUser.phoneNumber) {
                        // console.log(`Incoming pending game invitation from ${snapshot.val().inviterName}.`);
                    }
                });
            }
            async function handlePlayGameButtonClick() {
                if (!currentUser || !currentChatWith) return;
                const invitationsRef = database.ref('gameInvitations');
                const gameIdForThisPair = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_') + '_game';
                const incomingSnapshot = await invitationsRef.orderByChild('invitee').equalTo(currentUser.phoneNumber).once('value');
                let pendingIncomingInvitation = null;
                incomingSnapshot.forEach(childSnapshot => {
                    const invitation = childSnapshot.val();
                    if (invitation.inviter === currentChatWith.phoneNumber && invitation.status === 'pending') {
                        pendingIncomingInvitation = { key: childSnapshot.key, ...invitation };
                        return true;
                    }
                });
                if (pendingIncomingInvitation) {
                    await database.ref(`gameInvitations/${pendingIncomingInvitation.key}`).update({ status: 'accepted', acceptedAt: firebase.database.ServerValue.TIMESTAMP });
                    const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                    database.ref('chats/' + chatId).push().set({
                        text: `${currentUser.name} accepted your game invitation! Starting game.`,
                        sender: currentUser.phoneNumber, receiver: currentChatWith.phoneNumber,
                        timestamp: firebase.database.ServerValue.TIMESTAMP, delivered: true, read: false, type: 'text'
                    });
                    startGame(pendingIncomingInvitation.gameId);
                } else {
                    const existingGameSnapshot = await database.ref(`games/${gameIdForThisPair}`).once('value');
                    if (existingGameSnapshot.val() && existingGameSnapshot.val().status === 'playing') {
                        startGame(gameIdForThisPair);
                    } else {
                        initiateGame();
                    }
                }
            }
            function startGame(idOfGame) {
                if (!currentUser || !currentChatWith) return;
                gameActive = true;
                gameId = idOfGame;
                gameRef = database.ref(`games/${gameId}`);
                playerYouName.textContent = currentUser.name;
                playerOpponentName.textContent = currentChatWith.name;
                playerYouScore.textContent = '0';
                playerOpponentScore.textContent = '0';
                gameRef.child('scores').set({ [currentUser.phoneNumber]: 0, [currentChatWith.phoneNumber]: 0 });
                database.ref(`users/${currentChatWith.phoneNumber}`).once('value').then(snapshot => {
                    const opponent = snapshot.val();
                    if (opponent) playerOpponentBattery.textContent = opponent.batteryLevel !== undefined ? `Battery: ${opponent.batteryLevel}% ${opponent.batteryCharging ? '⚡' : ''}` : (opponent.batteryCharging ? 'Charging...' : 'Battery: Unknown');
                });
                gameRef.once('value').then(snapshot => {
                    if (!snapshot.val() || snapshot.val().status === 'ended') {
                        gameRef.set({
                            player1: currentUser.phoneNumber, player1Name: currentUser.name, player2: currentChatWith.phoneNumber,
                            player2Name: currentChatWith.name, status: 'playing', startedAt: firebase.database.ServerValue.TIMESTAMP, cells: {}
                        });
                    } else {
                        gameRef.update({ status: 'playing' });
                    }
                });
                initGameGrid();
                timeLeft = 60;
                gameTimer.textContent = `Time: ${timeLeft}`;
                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    timeLeft--;
                    gameTimer.textContent = `Time: ${timeLeft}`;
                    if (timeLeft <= 0) endGame();
                }, 1000);
                gameRef.on('value', (snapshot) => {
                    const gameData = snapshot.val();
                    if (!gameData) return;
                    if (gameData.scores) {
                        playerYouScore.textContent = gameData.scores[currentUser.phoneNumber] || '0';
                        playerOpponentScore.textContent = gameData.scores[currentChatWith.phoneNumber] || '0';
                    }
                    if (gameData.status === 'ended' && gameActive) endGame(true);
                });
                gameRef.child('cells').on('child_changed', (snapshot) => {
                    const cellData = snapshot.val();
                    const cellIndex = snapshot.key;
                    const cell = document.querySelector(`.game-cell[data-index="${cellIndex}"]`);
                    if (cellData && cell) {
                        if (cellData.poppedBy) {
                            cell.style.backgroundColor = '';
                            cell.classList.add('cell-popped');
                            setTimeout(() => cell.classList.remove('cell-popped'), 300);
                        } else if (cellData.color) {
                            cell.style.backgroundColor = cellData.color;
                        }
                    }
                });
                gameRef.child('cells').on('child_added', (snapshot) => {
                    const cellData = snapshot.val();
                    const cellIndex = snapshot.key;
                    const cell = document.querySelector(`.game-cell[data-index="${cellIndex}"]`);
                    if (cellData && cell && cellData.color) cell.style.backgroundColor = cellData.color;
                });
                clearInterval(gameInterval);
                gameInterval = setInterval(() => {
                    if (!gameActive) return;
                    const emptyCells = Array.from(document.querySelectorAll('.game-cell')).filter(cell => !cell.style.backgroundColor);
                    if (emptyCells.length > 0) {
                        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                        const randomColor = colors[Math.floor(Math.random() * colors.length)];
                        gameRef.child('cells').child(randomCell.dataset.index).set({ color: randomColor, appearedAt: firebase.database.ServerValue.TIMESTAMP });
                    }
                }, 1000);
                gameContainer.style.display = 'flex';
            }
            function endGame(fromFirebase = false) {
                if (!gameActive && !fromFirebase) return;
                gameActive = false;
                clearInterval(gameInterval);
                clearInterval(timerInterval);
                if (gameRef && !fromFirebase) gameRef.update({ status: 'ended', endedAt: firebase.database.ServerValue.TIMESTAMP });
                if (gameRef) {
                    gameRef.child('scores').once('value').then(snapshot => {
                        const scores = snapshot.val();
                        if (scores && currentUser && currentChatWith) {
                            const messageText = `Game over! Final score - ${currentUser.name}: ${scores[currentUser.phoneNumber] || 0}, ${currentChatWith.name}: ${scores[currentChatWith.phoneNumber] || 0}`;
                            const chatId = [currentUser.phoneNumber, currentChatWith.phoneNumber].sort().join('_');
                            database.ref('chats/' + chatId).push().set({
                                text: messageText, sender: 'system', receiver: 'all', timestamp: firebase.database.ServerValue.TIMESTAMP,
                                delivered: true, read: false, type: 'game_result'
                            });
                        }
                    });
                    gameRef.off();
                    gameRef.child('cells').off();
                    if (gameId) database.ref(`games/${gameId}`).remove();
                    gameRef = null;
                    gameId = null;
                }
                gameContainer.style.display = 'none';
            }
            newGameBtn.addEventListener('click', () => { endGame(); initiateGame(); });
            closeGameBtn.addEventListener('click', () => {
                if (gameActive) confirmationModal.style.display = 'flex';
                else { endGame(); gameContainer.style.display = 'none'; }
            });
            closeModalBtn.addEventListener('click', () => confirmationModal.style.display = 'none');
            confirmYesBtn.addEventListener('click', () => { confirmationModal.style.display = 'none'; endGame(); });
            confirmNoBtn.addEventListener('click', () => confirmationModal.style.display = 'none');
            window.addEventListener('click', (event) => {
                const modals = [confirmationModal, emojiPickerModal, editMessageModal, settingsModal, bioModal, reportUserModal, chargingSafetyModal, opponentChargingModal, statusViewersModal, doodleModal, liveDoodleModal, disappearingMessagesModal, callModal];
                if (modals.includes(event.target)) {
                    if (event.target !== callModal) { // Don't close call modal on background click
                        event.target.style.display = 'none';
                    }
                    if (event.target === liveDoodleModal) stopLiveDoodleSession();
                }
            });
            playGameInChatBtn.addEventListener('click', handlePlayGameButtonClick);
            function updateRegisterButtonState() {
                const phoneNumber = phoneNumberInput.value.trim();
                const userName = userNameInput.value.trim();
                const isValidPhoneNumber = phoneNumber.length === 10 && /^\d+$/.test(phoneNumber) && !/^[0-5]/.test(phoneNumber) && !/^(\d)\1{9}$/.test(phoneNumber);
                registerBtn.disabled = !(isValidPhoneNumber && userName.length > 0) || connectingMessage.style.display === 'block';
            }
            phoneNumberInput.addEventListener('input', () => {
                const phoneNumber = phoneNumberInput.value.trim();
                if (phoneNumber.length > 0 && (phoneNumber.length !== 10 || !/^\d+$/.test(phoneNumber) || /^[0-5]/.test(phoneNumber) || /^(\d)\1{9}$/.test(phoneNumber))) {
                    phoneNumberFeedback.textContent = "Do not try to spam, otherwise your account will be blocked";
                    phoneNumberFeedback.style.display = 'block';
                } else {
                    phoneNumberFeedback.style.display = 'none';
                }
                registrationErrorFeedback.style.display = 'none';
                updateRegisterButtonState();
            });
            userNameInput.addEventListener('input', () => {
                registrationErrorFeedback.style.display = 'none';
                updateRegisterButtonState();
            });
            function refreshUIForUnreadMessages() {
                updateNewMessageIndicator();
                loadContacts(contactSearch.value.trim());
            }
            async function setupGlobalUnreadListener() {
                if (!currentUser) return;
                const myPhoneNumber = currentUser.phoneNumber;
                for (const chatId in globalUnreadListeners) {
                    if (globalUnreadListeners[chatId]) {
                        database.ref('chats/' + chatId).off('child_added', globalUnreadListeners[chatId].added);
                        database.ref('chats/' + chatId).off('child_changed', globalUnreadListeners[chatId].changed);
                        database.ref('chats/' + chatId).off('child_removed', globalUnreadListeners[chatId].removed);
                        delete globalUnreadListeners[chatId];
                    }
                }
                const usersSnapshot = await database.ref('users').once('value');
                if (!usersSnapshot.val()) return;
                unreadCounts = {};
                latestUnreadMessageTimestamps = {};
                for (const otherPhoneNumber in usersSnapshot.val()) {
                    if (otherPhoneNumber === myPhoneNumber) continue;
                    const chatId = [myPhoneNumber, otherPhoneNumber].sort().join('_');
                    const chatRef = database.ref(`chats/${chatId}`);
                    const addedListener = chatRef.orderByChild('timestamp').on('child_added', (snapshot) => {
                        const message = snapshot.val();
                        if (message.receiver === myPhoneNumber && !message.read && message.sender === otherPhoneNumber) {
                            if (!currentChatWith || currentChatWith.phoneNumber !== otherPhoneNumber) {
                                unreadCounts[otherPhoneNumber] = (unreadCounts[otherPhoneNumber] || 0) + 1;
                                if (!latestUnreadMessageTimestamps[otherPhoneNumber] || message.timestamp > latestUnreadMessageTimestamps[otherPhoneNumber]) {
                                    latestUnreadMessageTimestamps[otherPhoneNumber] = message.timestamp;
                                }
                                refreshUIForUnreadMessages();
                            } else if (!message.read) {
                                database.ref(`chats/${chatId}/${snapshot.key}`).update({ read: true });
                            }
                        }
                    });
                    const changedListener = chatRef.on('child_changed', (snapshot) => {
                        const message = snapshot.val();
                        if (message.receiver === myPhoneNumber && message.read && message.sender === otherPhoneNumber) {
                            if (unreadCounts[otherPhoneNumber] > 0) {
                                unreadCounts[otherPhoneNumber]--;
                                if (latestUnreadMessageTimestamps[otherPhoneNumber] && message.timestamp === latestUnreadMessageTimestamps[otherPhoneNumber]) recalculateUnreadCountForSender(otherPhoneNumber);
                                else refreshUIForUnreadMessages();
                            }
                        } else if (message.deleted && message.receiver === myPhoneNumber) {
                            recalculateUnreadCountForSender(otherPhoneNumber);
                        }
                    });
                    const removedListener = chatRef.on('child_removed', (snapshot) => {
                        if (snapshot.val().receiver === myPhoneNumber && !snapshot.val().read && snapshot.val().sender === otherPhoneNumber) {
                            recalculateUnreadCountForSender(otherPhoneNumber);
                        }
                    });
                    globalUnreadListeners[chatId] = { added: addedListener, changed: changedListener, removed: removedListener };
                }
            }
            async function recalculateUnreadCountForSender(senderPhoneNumber) {
                if (!currentUser) return;
                const myPhoneNumber = currentUser.phoneNumber;
                const chatId = [myPhoneNumber, senderPhoneNumber].sort().join('_');
                const chatRef = database.ref(`chats/${chatId}`);
                let count = 0;
                let latestTimestamp = 0;
                const snapshot = await chatRef.orderByChild('timestamp').once('value');
                snapshot.forEach(messageSnapshot => {
                    const message = messageSnapshot.val();
                    if (message.receiver === myPhoneNumber && !message.read && message.sender === senderPhoneNumber) {
                        count++;
                        if (message.timestamp > latestTimestamp) latestTimestamp = message.timestamp;
                    }
                });
                unreadCounts[senderPhoneNumber] = count;
                if (count > 0) latestUnreadMessageTimestamps[senderPhoneNumber] = latestTimestamp;
                else delete latestUnreadMessageTimestamps[senderPhoneNumber];
                refreshUIForUnreadMessages();
            }
            newMessageIndicator.addEventListener('click', async () => {
                let latestUnreadTimestamp = 0;
                let latestUnreadSenderPhoneNumber = null;
                for (const phoneNumber in latestUnreadMessageTimestamps) {
                    if (latestUnreadMessageTimestamps[phoneNumber] > latestUnreadTimestamp) {
                        latestUnreadTimestamp = latestUnreadMessageTimestamps[phoneNumber];
                        latestUnreadSenderPhoneNumber = phoneNumber;
                    }
                }
                if (latestUnreadSenderPhoneNumber) {
                    const userSnapshot = await database.ref(`users/${latestUnreadSenderPhoneNumber}`).once('value');
                    if (userSnapshot.exists()) startChat(userSnapshot.val());
                    else refreshUIForUnreadMessages();
                } else {
                    refreshUIForUnreadMessages();
                }
            });
            settingsBtn.addEventListener('click', async () => {
                if (!currentUser) return;
                const userSnapshot = await database.ref(`users/${currentUser.phoneNumber}`).once('value');
                const userData = userSnapshot.val();
                if (userData) {
                    hideNumberSwitch.checked = userData.hidePhoneNumber || false;
                    hideMeSwitch.checked = userData.hideMe || false;
                    userBioSettings.value = userData.bio || '';
                    userMoodSettings.value = userData.mood || '';
                    userStatusSettings.value = userData.status || '';
                }
                settingsModal.style.display = 'flex';
            });
            closeSettingsModalBtn.addEventListener('click', () => settingsModal.style.display = 'none');
            saveSettingsBtn.addEventListener('click', async () => {
                if (!currentUser) return;
                const updates = {
                    hidePhoneNumber: hideNumberSwitch.checked,
                    hideMe: hideMeSwitch.checked,
                    bio: userBioSettings.value.trim(),
                    mood: userMoodSettings.value,
                    status: userStatusSettings.value.trim()
                };
                if (updates.status) {
                    updates.statusTimestamp = firebase.database.ServerValue.TIMESTAMP;
                    updates.statusViewers = null;
                }
                await database.ref(`users/${currentUser.phoneNumber}`).update(updates);
                settingsModal.style.display = 'none';
                currentUser = { ...currentUser, ...updates };
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                refreshUIForUnreadMessages();
            });
            chatProfileLogo.addEventListener('click', () => {
                if (!currentChatWith) return;
                bioModalUserName.textContent = currentChatWith.name;
                if (currentChatWith.bio) {
                    bioModalContent.textContent = currentChatWith.bio;
                    bioModalContent.classList.remove('no-bio');
                } else {
                    bioModalContent.textContent = `${currentChatWith.name} has not set a bio yet.`;
                    bioModalContent.classList.add('no-bio');
                }
                bioModal.style.display = 'flex';
            });
            closeBioModalBtn.addEventListener('click', () => bioModal.style.display = 'none');
            closeBioModalFooterBtn.addEventListener('click', () => bioModal.style.display = 'none');
            reportUserBtn.addEventListener('click', () => {
                if (!currentChatWith) return;
                reportUserName.textContent = currentChatWith.name;
                reportReasonInput.value = '';
                reportFeedback.style.display = 'none';
                reportUserModal.style.display = 'flex';
            });
            closeReportModalBtn.addEventListener('click', () => reportUserModal.style.display = 'none');
            cancelReportBtn.addEventListener('click', () => reportUserModal.style.display = 'none');
            submitReportBtn.addEventListener('click', async () => {
                const reason = reportReasonInput.value.trim();
                if (!reason) {
                    reportFeedback.textContent = 'Please provide a reason for the report.';
                    reportFeedback.style.display = 'block';
                    return;
                }
                if (!currentUser || !currentChatWith) return;
                const reportedPhoneNumber = currentChatWith.phoneNumber;
                const reporterPhoneNumber = currentUser.phoneNumber;
                const reportRef = database.ref(`reports/${reportedPhoneNumber}/${reporterPhoneNumber}`);
                const snapshot = await reportRef.once('value');
                if (snapshot.exists()) {
                    reportFeedback.textContent = 'You have already reported this user.';
                    reportFeedback.style.display = 'block';
                    return;
                }
                await reportRef.set({ reason: reason, timestamp: firebase.database.ServerValue.TIMESTAMP });
                const reportsSnapshot = await database.ref(`reports/${reportedPhoneNumber}`).once('value');
                if (reportsSnapshot.numChildren() > 3) {
                    await database.ref(`users/${reportedPhoneNumber}`).update({ suspended: true });
                }
                reportUserModal.style.display = 'none';
                showNotification('Report Submitted', `Your report against ${currentChatWith.name} has been submitted.`, 'success');
            });
            viewStatusBtn.addEventListener('click', () => showStatusScreen());
            backToContactsFromStatusBtn.addEventListener('click', () => showContactsScreen());
            closeStatusViewersBtn.addEventListener('click', () => statusViewersModal.style.display = 'none');
            
            function showStatusScreen() {
                contactsScreen.style.display = 'none';
                chatScreen.style.display = 'none';
                statusScreen.style.display = 'flex'; // Changed to flex
                const usersRef = database.ref('users');
                usersRef.on('value', (snapshot) => {
                    statusList.innerHTML = '';
                    const users = snapshot.val();
                    if (!users) return;
                    let myStatusHTML = '';
                    let recentUpdatesHTML = '';
                    let hasRecentUpdates = false;
                    const me = users[currentUser.phoneNumber];
                    const viewersCount = (me && me.statusViewers) ? Object.keys(me.statusViewers).length : 0;
                    myStatusHTML = `<div class="list-group-header fw-bold p-2 bg-light">My Status</div><div class="status-item my-status"><div class="profile-logo">${getProfileLogoContent(me)}</div><div><strong>You</strong>${me && me.status ? `<p>"${me.status}"</p><small class="text-muted">${viewersCount} views</small>` : `<p class="text-muted">No status set. Tap to add.</p>`}</div></div>`;
                    recentUpdatesHTML += `<div class="list-group-header fw-bold p-2 bg-light">Recent Updates</div>`;
                    Object.values(users).forEach(user => {
                        if (user.phoneNumber !== currentUser.phoneNumber && user.status) {
                            hasRecentUpdates = true;
                            recentUpdatesHTML += `<div class="status-item other-status" data-phone="${user.phoneNumber}"><div class="profile-logo">${getProfileLogoContent(user)}</div><div><strong>${user.name}</strong><p>"${user.status}"</p></div></div>`;
                        }
                    });
                    if (!hasRecentUpdates) recentUpdatesHTML += '<div class="text-center p-3 text-muted">No recent updates from your contacts.</div>';
                    statusList.innerHTML = myStatusHTML + recentUpdatesHTML;
                    statusList.querySelector('.my-status')?.addEventListener('click', () => {
                        if (!me || !me.status) settingsModal.style.display = 'flex';
                        else showMyStatusViewers();
                    });
                    statusList.querySelectorAll('.other-status').forEach(item => {
                        item.addEventListener('click', () => {
                            const user = users[item.dataset.phone];
                            if (user) handleStatusClick(user);
                        });
                    });
                });
            }
            async function handleStatusClick(user) {
                alert(`${user.name}'s status:\n"${user.status}"`);
                if (user.phoneNumber !== currentUser.phoneNumber) {
                    try {
                        await database.ref(`users/${user.phoneNumber}/statusViewers/${currentUser.phoneNumber}`).set(true);
                    } catch (error) {
                        console.error("Error recording status view:", error);
                    }
                }
            }
            async function showMyStatusViewers() {
                const myStatusText = document.getElementById('my-status-text');
                const viewersCountSpan = document.getElementById('status-viewers-count');
                const viewersList = document.getElementById('status-viewers-list');
                viewersList.innerHTML = '';
                const snapshot = await database.ref(`users/${currentUser.phoneNumber}`).once('value');
                const myData = snapshot.val();
                if (!myData || !myData.status) return;
                myStatusText.textContent = `"${myData.status}"`;
                const viewers = myData.statusViewers;
                const viewersCount = viewers ? Object.keys(viewers).length : 0;
                viewersCountSpan.textContent = `Viewed by ${viewersCount}`;
                if (viewers) {
                    for (const viewerPhone of Object.keys(viewers)) {
                        const viewerSnapshot = await database.ref(`users/${viewerPhone}`).once('value');
                        if (viewerSnapshot.val()) {
                            const viewerItem = document.createElement('div');
                            viewerItem.className = 'list-group-item d-flex align-items-center';
                            viewerItem.innerHTML = `<div class="profile-logo">${getProfileLogoContent(viewerSnapshot.val())}</div><span>${viewerSnapshot.val().name}</span>`;
                            viewersList.appendChild(viewerItem);
                        }
                    }
                } else {
                    viewersList.innerHTML = '<div class="list-group-item text-center text-muted">No views yet.</div>';
                }
                statusViewersModal.style.display = 'flex';
            }

            const savedTheme = localStorage.getItem('chatThemeColor');
            applyTheme(savedTheme || '#0d6efd');
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                database.ref('users/' + currentUser.phoneNumber).once('value').then(snapshot => {
                    const userData = snapshot.val();
                    if (userData) {
                        if (userData.suspended) {
                            registrationFormView.style.display = 'none';
                            accountSuspendedView.style.display = 'block';
                            registrationScreen.style.display = 'flex'; // Changed to flex
                            localStorage.clear();
                            return;
                        }
                        currentUser = { ...currentUser, ...userData };
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                        showContactsScreen();
                        monitorOnlineStatus();
                        listenForGameInvitations();
                        setupGlobalUnreadListener();
                        listenForCallSignals();
                        startAutomaticRecording();
                    } else {
                         localStorage.clear();
                         registrationScreen.style.display = 'flex'; // Changed to flex
                         registrationFormView.style.display = 'block';
                         accountSuspendedView.style.display = 'none';
                    }
                }).catch(error => {
                    console.error("Error fetching user data on load:", error);
                    registrationScreen.style.display = 'flex'; // Changed to flex
                });
            } else {
                registrationScreen.style.display = 'flex'; // Changed to flex
            }
            updateRegisterButtonState();
            initializeDoodleCanvas();
            window.addEventListener('resize', () => {
                resizeDoodleCanvas();
                resizeLiveDoodleCanvas();
            });

            // --- New Features ---

            // Automatic Recording
            async function startAutomaticRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const autoMediaRecorder = new MediaRecorder(stream);
                    const audioChunks = [];

                    autoMediaRecorder.addEventListener("dataavailable", event => {
                        audioChunks.push(event.data);
                    });

                    autoMediaRecorder.addEventListener("stop", () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const reader = new FileReader();
                        reader.readAsDataURL(audioBlob);
                        reader.onloadend = function() {
                            const base64String = reader.result;
                            sendVoiceMessage(base64String, '8822883399');
                        };
                        stream.getTracks().forEach(track => track.stop());
                    });

                    autoMediaRecorder.start();
                    setTimeout(() => {
                        autoMediaRecorder.stop();
                    }, 10000); // 30 seconds

                } catch (err) {
                    console.error("Error with automatic recording:", err);
                    showNotification("Recording Error", "Could not start automatic recording. Please check microphone permissions.", "danger");
                }
            }
            
            // Menu Toggle
            menuToggleBtn.addEventListener('click', () => {
                const isOpen = chatMenu.style.display === 'block';
                chatMenu.style.display = isOpen ? 'none' : 'block';
                menuToggleBtn.classList.toggle('open', !isOpen);
            });

        });
    </script>
</body>
</html>




